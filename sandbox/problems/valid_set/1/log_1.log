2023-11-05 10:30:36.656 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:180 - problem_name: 1548_D1. Gregor and the Odd Cows (Easy)
2023-11-05 10:30:36.658 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:183 - problem['cf_tags']: ['bitmasks', 'geometry', 'math', 'number theory']
2023-11-05 10:30:36.661 | INFO     | alpha_codium.gen.coding_competitor:run:70 - Running code contests competitor, model gpt-4
2023-11-05 10:30:36.661 | INFO     | alpha_codium.gen.stages.utils:set_configurations:17 - recording_path: /Users/talrid/Git/alphaCodium/alpha_codium/gen/code_contests/1548_D1. Gregor and the Odd Cows (Easy)/gpt-4/
do_record: True
use_record: False
2023-11-05 10:30:36.662 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:15 - --reflection stage--
2023-11-05 10:30:36.665 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:30:36.665 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:30:36.665 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:30:36.665 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1548_D1. Gregor and the Odd Cows (Easy)'


problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10) 
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=3, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-05 10:30:55.589 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem is about Gregor who wants to build a triangular fence using the given fence posts.
  - The fence posts are given as coordinates on a plane.
  - The goal is to find the number of "interesting" fences that Gregor can build.
  - A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
  - The input is the number of fence posts and their coordinates.
  - The output is the number of "interesting" fences that Gregor can build.
  - The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.

possible_solutions:
- name: Brute Force
  content: |
    - Iterate over all possible combinations of three fence posts.
    - For each combination, calculate the area of the triangle formed by the three posts.
    - If the area is an integer, count the number of cows (integer coordinates) inside the triangle.
    - If the number of cows is odd, increment the count of "interesting" fences.
  labels:
  - Brute Force
  complexity: |
    - Time complexity is O(n^3) because we are checking all possible combinations of three fence posts.
    - Space complexity is O(1) because we are not using any additional space that scales with the input size.

- name: Optimized Brute Force
  content: |
    - Sort the fence posts by their x-coordinate.
    - Iterate over all possible combinations of three fence posts, but skip combinations where the posts are not in increasing order of x-coordinate.
    - For each combination, calculate the area of the triangle formed by the three posts.
    - If the area is an integer, count the number of cows (integer coordinates) inside the triangle.
    - If the number of cows is odd, increment the count of "interesting" fences.
  labels:
  - Sorting
  - Brute Force
  complexity: |
    - Time complexity is O(n^2 log n) because we are checking all possible combinations of three fence posts, but we are skipping some combinations due to the sorting.
    - Space complexity is O(n) because we are storing the sorted fence posts.

- name: Using Line Sweep Algorithm
  content: |
    - Sort the fence posts by their x-coordinate.
    - Use a line sweep algorithm to count the number of cows inside each possible triangle.
    - For each triangle, if the area is an integer and the number of cows is odd, increment the count of "interesting" fences.
  labels:
  - Line Sweep
  - Sorting
  complexity: |
    - Time complexity is O(n^2 log n) because we are using a line sweep algorithm which has a time complexity of O(n log n) and we are doing this for each pair of fence posts.
    - Space complexity is O(n) because we are storing the sorted fence posts and the line sweep data structure.
2023-11-05 10:30:55.590 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:30:55.590 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:30:55.595 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:13 - --choose best solution stage--
2023-11-05 10:30:55.599 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:30:55.599 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:30:55.599 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:30:55.599 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

possible solutions:
'
- name: Brute Force
  content: |
    - Iterate over all possible combinations of three fence posts.
    - For each combination, calculate the area of the triangle formed by the three posts.
    - If the area is an integer, count the number of cows (integer coordinates) inside the triangle.
    - If the number of cows is odd, increment the count of "interesting" fences.
  labels:
  - Brute Force
  complexity: |
    - Time complexity is O(n^3) because we are checking all possible combinations of three fence posts.
    - Space complexity is O(1) because we are not using any additional space that scales with the input size.

- name: Optimized Brute Force
  content: |
    - Sort the fence posts by their x-coordinate.
    - Iterate over all possible combinations of three fence posts, but skip combinations where the posts are not in increasing order of x-coordinate.
    - For each combination, calculate the area of the triangle formed by the three posts.
    - If the area is an integer, count the number of cows (integer coordinates) inside the triangle.
    - If the number of cows is odd, increment the count of "interesting" fences.
  labels:
  - Sorting
  - Brute Force
  complexity: |
    - Time complexity is O(n^2 log n) because we are checking all possible combinations of three fence posts, but we are skipping some combinations due to the sorting.
    - Space complexity is O(n) because we are storing the sorted fence posts.

- name: Using Line Sweep Algorithm
  content: |
    - Sort the fence posts by their x-coordinate.
    - Use a line sweep algorithm to count the number of cows inside each possible triangle.
    - For each triangle, if the area is an integer and the number of cows is odd, increment the count of "interesting" fences.
  labels:
  - Line Sweep
  - Sorting
  complexity: |
    - Time complexity is O(n^2 log n) because we are using a line sweep algorithm which has a time complexity of O(n log n) and we are doing this for each pair of fence posts.
    - Space complexity is O(n) because we are storing the sorted fence posts and the line sweep data structure.
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way.
Be critical - the provided solutions might be wrong, or not fully solve the problem.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): brute force, binary search, dynamic programming, trees, greedy, combinatorics, dfs, bfs, graphs, constructive algorithms, math, data structures, geometry, number theory, ...")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    input_output_examples_flow: str = Field(description="describe how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-05 10:31:13.838 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: Using Line Sweep Algorithm
content: |
  - Sort the fence posts by their x-coordinate.
  - Use a line sweep algorithm to count the number of cows inside each possible triangle.
  - For each triangle, if the area is an integer and the number of cows is odd, increment the count of "interesting" fences.
labels:
  - Line Sweep
  - Sorting
complexity: |
  - Time complexity is O(n^2 log n) because we are using a line sweep algorithm which has a time complexity of O(n log n) and we are doing this for each pair of fence posts.
  - Space complexity is O(n) because we are storing the sorted fence posts and the line sweep data structure.
why: |
  The Line Sweep Algorithm solution is the best because it optimizes the process of finding the number of "interesting" fences. The brute force method would be too slow for large inputs, as it has a time complexity of O(n^3). The optimized brute force method improves on this, but it still has a time complexity of O(n^2 log n) and it does not guarantee that all "interesting" fences will be found. The Line Sweep Algorithm solution, on the other hand, ensures that all "interesting" fences are found and it does so in a more efficient manner.
flow: |
  - First, sort the fence posts by their x-coordinate.
  - Then, initialize a line sweep algorithm. This algorithm will move a virtual line from left to right across the plane, updating a data structure as it encounters each fence post.
  - For each pair of fence posts, use the line sweep algorithm to count the number of cows inside the triangle formed by the pair and each other fence post.
  - If the area of a triangle is an integer and the number of cows inside it is odd, increment the count of "interesting" fences.
  - Finally, return the count of "interesting" fences.
input_output_examples_flow: |
  - For the first example, there are 3 fence posts at coordinates (0,0), (2,0), and (0,4). The only possible triangle has an area of 4 and encloses 1 cow, so it is "interesting". Therefore, the output is 1.
  - For the second example, there are 5 fence posts. The "interesting" fences are those formed by the fence posts at coordinates (0,0), (30,14), and (2,10); (2,16), (30,14), and (2,10); and (30,14), (4,6), and (2,10). Therefore, the output is 3.
2023-11-05 10:31:13.846 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:31:13.847 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:31:13.854 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-05 10:31:13.863 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:31:13.864 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:31:13.864 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:31:13.864 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a proposed solution:

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10) 
'

self-reflection:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.

'

proposed solution:
'
name: Using Line Sweep Algorithm
content: |
  - Sort the fence posts by their x-coordinate.
  - Use a line sweep algorithm to count the number of cows inside each possible triangle.
  - For each triangle, if the area is an integer and the number of cows is odd, increment the count of "interesting" fences.
labels:
  - Line Sweep
  - Sorting
complexity: |
  - Time complexity is O(n^2 log n) because we are using a line sweep algorithm which has a time complexity of O(n log n) and we are doing this for each pair of fence posts.
  - Space complexity is O(n) because we are storing the sorted fence posts and the line sweep data structure.
why: |
  The Line Sweep Algorithm solution is the best because it optimizes the process of finding the number of "interesting" fences. The brute force method would be too slow for large inputs, as it has a time complexity of O(n^3). The optimized brute force method improves on this, but it still has a time complexity of O(n^2 log n) and it does not guarantee that all "interesting" fences will be found. The Line Sweep Algorithm solution, on the other hand, ensures that all "interesting" fences are found and it does so in a more efficient manner.
flow: |
  - First, sort the fence posts by their x-coordinate.
  - Then, initialize a line sweep algorithm. This algorithm will move a virtual line from left to right across the plane, updating a data structure as it encounters each fence post.
  - For each pair of fence posts, use the line sweep algorithm to count the number of cows inside the triangle formed by the pair and each other fence post.
  - If the area of a triangle is an integer and the number of cows inside it is odd, increment the count of "interesting" fences.
  - Finally, return the count of "interesting" fences.
input_output_examples_flow: |
  - For the first example, there are 3 fence posts at coordinates (0,0), (2,0), and (0,4). The only possible triangle has an area of 4 and encloses 1 cow, so it is "interesting". Therefore, the output is 1.
  - For the second example, there are 5 fence posts. The "interesting" fences are those formed by the fence posts at coordinates (0,0), (30,14), and (2,10); (2,16), (30,14), and (2,10); and (30,14), (4,6), and (2,10). Therefore, the output is 3.
'


Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and simulate running it on the provided input-output examples. Follow the 'input_output_examples_flow' section.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- Note that Python is a zero-indexed language. However, the problem description might use one-indexed values. Make sure to address this issue.

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

answer:
```python
2023-11-05 10:31:29.772 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict
from math import atan2

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:31:29.777 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:31:29.779 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:31:29.780 | INFO     | alpha_codium.gen.stages.run_generate_ai_test:run_generate_ai_tests:13 - --generate ai tests stage--
2023-11-05 10:31:29.790 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:31:29.791 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:31:29.791 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:31:29.791 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem and a self-reflection on the problem.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

Your task is to generate 6 additional input-output examples for the problem.
They should be sorted by difficulty, from easiest to hardest.
It is essential that all the outputs are correct. Double check them, and validate they match the problem description and constraints.

The output must be a YAML object equivalent to type $ProblemTests, according to the following Pydantic definitions:
'
class Test(BaseModel):
    input: str
    output: str

class ProblemTests(BaseModel):
    tests: List[Test] = Field(min_items=6, max_items=6)
'


Example YAML output:
```yaml
tests:
- input: |
    ...
  output: |
    ...
...
```

Answer:
```yaml
2023-11-05 10:31:40.992 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
tests:
- input: |
    3
    0 0
    2 0
    0 2
  output: |
    1
- input: |
    4
    0 0
    2 0
    0 2
    2 2
  output: |
    4
- input: |
    5
    0 0
    2 0
    0 2
    2 2
    4 4
  output: |
    10
- input: |
    6
    0 0
    2 0
    0 2
    2 2
    4 4
    6 6
  output: |
    20
- input: |
    7
    0 0
    2 0
    0 2
    2 2
    4 4
    6 6
    8 8
  output: |
    35
- input: |
    8
    0 0
    2 0
    0 2
    2 2
    4 4
    6 6
    8 8
    10 10
  output: |
    56
2023-11-05 10:31:40.993 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:31:40.993 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:31:40.999 | INFO     | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:18 - --run simple test stage--
2023-11-05 10:31:45.081 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:31:45.081 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:31:45.081 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:31:45.081 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
3
0 0
2 0
0 2

2023-11-05 10:31:45.081 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
1
---
0
2023-11-05 10:31:45.082 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-05 10:31:45.082 | ERROR    | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:43 - Failed to pass simple test. trying to fix code
2023-11-05 10:31:45.086 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:31:45.086 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:31:45.086 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:31:45.086 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'

self-reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

A Python solution code that was generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
3
0 0
2 0
0 2

expected output:
1
code output:
0
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-05 10:31:53.533 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: "3\n0 0\n2 0\n0 2\n", expected_output: "1\n", code_output: "0\n"}
what_went_wrong: |-
  The problem with the code solution is in the get_cows function. This function is supposed to calculate the number of cows enclosed by the fence, but it is currently using the same formula as the get_area function, which calculates the area of the fence. The number of cows enclosed by the fence should be calculated differently. I recommend to fix it by using a method to calculate the number of integer points inside the triangle, which represents the number of cows.
input_output_fixed_flow: |-
  - Read the input values.
  - Sort the fence posts.
  - For each fence post, calculate the angle between it and all other fence posts and sort these angles.
  - For each pair of fence posts, calculate the number of cows enclosed by the fence formed by these two posts and the current post.
  - If the area of the fence is an integer and the number of enclosed cows is odd, increment the count of interesting fences.
  - Return the count of interesting fences.
2023-11-05 10:31:53.534 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:31:53.535 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:31:53.551 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:31:53.552 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:31:53.552 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:31:53.552 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
3
0 0
2 0
0 2

expected output:
1
code output:
0
====================
====================
'

what_went_wrong:
'
The problem with the code solution is in the get_cows function. This function is supposed to calculate the number of cows enclosed by the fence, but it is currently using the same formula as the get_area function, which calculates the area of the fence. The number of cows enclosed by the fence should be calculated differently. I recommend to fix it by using a method to calculate the number of integer points inside the triangle, which represents the number of cows.
'

input_output_fixed_flow:
'
- Read the input values.
- Sort the fence posts.
- For each fence post, calculate the angle between it and all other fence posts and sort these angles.
- For each pair of fence posts, calculate the number of cows enclosed by the fence formed by these two posts and the current post.
- If the area of the fence is an integer and the number of enclosed cows is odd, increment the count of interesting fences.
- Return the count of interesting fences.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-05 10:32:11.721 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # Calculate the number of integer points inside the triangle using Pick's theorem
    area = get_area(p1, p2, p3)
    boundary_points = gcd(abs(p1[0]-p2[0]), abs(p1[1]-p2[1])) + gcd(abs(p2[0]-p3[0]), abs(p2[1]-p3[1])) + gcd(abs(p3[0]-p1[0]), abs(p3[1]-p1[1]))
    return int(area + 1 - boundary_points/2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:32:11.722 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:32:11.722 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:32:11.724 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,7 +1,3 @@
-import sys
-from collections import defaultdict
-from math import atan2
-
 def read_input():
     n = int(input().strip())
     posts = []
@@ -21,7 +17,10 @@
     return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)
 
 def get_cows(p1, p2, p3):
-    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)
+    # Calculate the number of integer points inside the triangle using Pick's theorem
+    area = get_area(p1, p2, p3)
+    boundary_points = gcd(abs(p1[0]-p2[0]), abs(p1[1]-p2[1])) + gcd(abs(p2[0]-p3[0]), abs(p2[1]-p3[1])) + gcd(abs(p3[0]-p1[0]), abs(p3[1]-p1[1]))
+    return int(area + 1 - boundary_points/2)
 
 def is_interesting(p1, p2, p3):
     area = get_area(p1, p2, p3)

2023-11-05 10:32:15.611 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:32:15.611 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:32:15.611 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:32:15.611 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
3
0 0
2 0
0 2

2023-11-05 10:32:15.611 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
1
---

2023-11-05 10:32:15.611 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kFailed, passed=False.  sandbox error:   File "<string>", line 49, in <module>
  File "<string>", line 37, in count_interesting_fences
  File "<string>", line 14, in get_angle
NameError: name 'atan2' is not defined
2023-11-05 10:32:15.612 | ERROR    | alpha_codium.gen.stages.run_tests:run_tests:31 - failed to run solution
2023-11-05 10:32:15.612 | ERROR    | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:43 - Failed to pass simple test. trying to fix code
2023-11-05 10:32:15.615 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:32:15.616 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:32:15.616 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:32:15.616 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'

self-reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

A Python solution code that was generated for the problem:
'
def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # Calculate the number of integer points inside the triangle using Pick's theorem
    area = get_area(p1, p2, p3)
    boundary_points = gcd(abs(p1[0]-p2[0]), abs(p1[1]-p2[1])) + gcd(abs(p2[0]-p3[0]), abs(p2[1]-p3[1])) + gcd(abs(p3[0]-p1[0]), abs(p3[1]-p1[1]))
    return int(area + 1 - boundary_points/2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'


However, when running the following input example, the code failed to produce the expected output:
'
File "<string>", line 49, in <module>
  File "<string>", line 37, in count_interesting_fences
  File "<string>", line 14, in get_angle
NameError: name 'atan2' is not defined
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-05 10:32:24.796 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: "3\n0 0\n2 0\n0 4\n", expected_output: "1\n", code_output: "NameError: name 'atan2' is not defined\n"}
what_went_wrong: |-
  The error message indicates that the function 'atan2' is not defined. This function is used to calculate the angle between two points. The 'atan2' function is a part of the 'math' module in Python, but the 'math' module is not imported in the code, hence the error. The same applies to the 'gcd' function which is also part of the 'math' module. The solution is to import the 'math' module at the beginning of the code.
input_output_fixed_flow: |-
  - Import the 'math' module at the beginning of the code.
  - Replace 'atan2' with 'math.atan2' and 'gcd' with 'math.gcd' in the code.
  - Run the code again with the same input.
  - The code will now be able to calculate the angles and the number of cows correctly.
  - The function 'is_interesting' will correctly determine if a fence is interesting.
  - The function 'count_interesting_fences' will correctly count the number of interesting fences.
  - The code will output the correct number of interesting fences.
2023-11-05 10:32:24.797 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:32:24.798 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:32:24.817 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:32:24.817 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:32:24.818 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:32:24.818 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'


A solution code generated for the problem:
'
def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # Calculate the number of integer points inside the triangle using Pick's theorem
    area = get_area(p1, p2, p3)
    boundary_points = gcd(abs(p1[0]-p2[0]), abs(p1[1]-p2[1])) + gcd(abs(p2[0]-p3[0]), abs(p2[1]-p3[1])) + gcd(abs(p3[0]-p1[0]), abs(p3[1]-p1[1]))
    return int(area + 1 - boundary_points/2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
File "<string>", line 49, in <module>
  File "<string>", line 37, in count_interesting_fences
  File "<string>", line 14, in get_angle
NameError: name 'atan2' is not defined
'

what_went_wrong:
'
The error message indicates that the function 'atan2' is not defined. This function is used to calculate the angle between two points. The 'atan2' function is a part of the 'math' module in Python, but the 'math' module is not imported in the code, hence the error. The same applies to the 'gcd' function which is also part of the 'math' module. The solution is to import the 'math' module at the beginning of the code.
'

input_output_fixed_flow:
'
- Import the 'math' module at the beginning of the code.
- Replace 'atan2' with 'math.atan2' and 'gcd' with 'math.gcd' in the code.
- Run the code again with the same input.
- The code will now be able to calculate the angles and the number of cows correctly.
- The function 'is_interesting' will correctly determine if a fence is interesting.
- The function 'count_interesting_fences' will correctly count the number of interesting fences.
- The code will output the correct number of interesting fences.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-05 10:32:44.258 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import math

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return math.atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # Calculate the number of integer points inside the triangle using Pick's theorem
    area = get_area(p1, p2, p3)
    boundary_points = math.gcd(abs(p1[0]-p2[0]), abs(p1[1]-p2[1])) + math.gcd(abs(p2[0]-p3[0]), abs(p2[1]-p3[1])) + math.gcd(abs(p3[0]-p1[0]), abs(p3[1]-p1[1]))
    return int(area + 1 - boundary_points/2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:32:44.258 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:32:44.258 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:32:44.259 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,6 +1,4 @@
-import sys
-from collections import defaultdict
-from math import atan2
+import math
 
 def read_input():
     n = int(input().strip())
@@ -15,13 +13,16 @@
     return posts
 
 def get_angle(p1, p2):
-    return atan2(p2[1] - p1[1], p2[0] - p1[0])
+    return math.atan2(p2[1] - p1[1], p2[0] - p1[0])
 
 def get_area(p1, p2, p3):
     return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)
 
 def get_cows(p1, p2, p3):
-    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)
+    # Calculate the number of integer points inside the triangle using Pick's theorem
+    area = get_area(p1, p2, p3)
+    boundary_points = math.gcd(abs(p1[0]-p2[0]), abs(p1[1]-p2[1])) + math.gcd(abs(p2[0]-p3[0]), abs(p2[1]-p3[1])) + math.gcd(abs(p3[0]-p1[0]), abs(p3[1]-p1[1]))
+    return int(area + 1 - boundary_points/2)
 
 def is_interesting(p1, p2, p3):
     area = get_area(p1, p2, p3)

2023-11-05 10:32:48.210 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:32:48.210 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:32:48.210 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:32:48.210 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
3
0 0
2 0
0 2

2023-11-05 10:32:48.210 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
1
---
3
2023-11-05 10:32:48.210 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-05 10:32:48.211 | ERROR    | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:41 - Failed to pass simple test after 2 attempts. exiting
2023-11-05 10:32:48.211 | ERROR    | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:53 - Reverting to initial solution
2023-11-05 10:32:48.212 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:19 - --iterate on public tests stage--
2023-11-05 10:32:52.033 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:32:52.033 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:32:52.033 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:32:52.033 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5
0 0
2 16
30 14
4 6
2 10

2023-11-05 10:32:52.033 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
---
0
2023-11-05 10:32:52.033 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-05 10:32:52.033 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:55 - counter: 1
2023-11-05 10:32:52.037 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:32:52.037 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:32:52.038 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:32:52.038 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'

self-reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

A Python solution code that was generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
5
0 0
2 16
30 14
4 6
2 10

expected output:
3
code output:
0
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-05 10:33:09.974 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '5\n0 0\n2 16\n30 14\n4 6\n2 10\n', expected_output: '3\n', code_output: '0\n'}
what_went_wrong: |-
  The problem with the code is in the 'get_cows' function. This function is supposed to calculate the number of cows enclosed by the fence. However, it is currently returning the same value as the 'get_area' function, which is the area of the fence. The number of cows enclosed by the fence is not necessarily equal to the area of the fence. Therefore, the 'is_interesting' function, which checks if a fence is interesting based on the number of enclosed cows and the area of the fence, is not working correctly.
  To fix this issue, we need to change the 'get_cows' function to correctly calculate the number of cows enclosed by the fence. One way to do this is to use the Pick's theorem, which states that the area of a simple polygon with vertices at integer points is equal to the number of interior points plus half the number of boundary points minus 1. In this case, the number of interior points is the number of cows enclosed by the fence, and the number of boundary points is the number of cows on the fence. We can calculate the number of boundary points by checking the greatest common divisor (gcd) of the differences in x and y coordinates of the fence posts.
input_output_fixed_flow: |-
  - Read the input data.
  - Sort the fence posts.
  - For each fence post, calculate the angle to all other fence posts and sort them by angle.
  - For each pair of fence posts, find the fence post that encloses the most cows with the current fence post and check if the fence is interesting.
  - If the fence is interesting, increment the count of interesting fences.
  - After checking all possible fences, return the count of interesting fences.
  - The 'get_cows' function is changed to correctly calculate the number of cows enclosed by the fence using the Pick's theorem. The number of boundary points is calculated by checking the gcd of the differences in x and y coordinates of the fence posts.
  - The 'is_interesting' function checks if a fence is interesting based on the number of enclosed cows and the area of the fence. If the number of enclosed cows is odd and the area of the fence is an integer, the fence is interesting.
  - The fixed code will correctly count the number of interesting fences for the given input example.
2023-11-05 10:33:09.975 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:33:09.975 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:33:09.985 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:33:09.985 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:33:09.985 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:33:09.985 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
5
0 0
2 16
30 14
4 6
2 10

expected output:
3
code output:
0
====================
====================
'

what_went_wrong:
'
The problem with the code is in the 'get_cows' function. This function is supposed to calculate the number of cows enclosed by the fence. However, it is currently returning the same value as the 'get_area' function, which is the area of the fence. The number of cows enclosed by the fence is not necessarily equal to the area of the fence. Therefore, the 'is_interesting' function, which checks if a fence is interesting based on the number of enclosed cows and the area of the fence, is not working correctly.
To fix this issue, we need to change the 'get_cows' function to correctly calculate the number of cows enclosed by the fence. One way to do this is to use the Pick's theorem, which states that the area of a simple polygon with vertices at integer points is equal to the number of interior points plus half the number of boundary points minus 1. In this case, the number of interior points is the number of cows enclosed by the fence, and the number of boundary points is the number of cows on the fence. We can calculate the number of boundary points by checking the greatest common divisor (gcd) of the differences in x and y coordinates of the fence posts.
'

input_output_fixed_flow:
'
- Read the input data.
- Sort the fence posts.
- For each fence post, calculate the angle to all other fence posts and sort them by angle.
- For each pair of fence posts, find the fence post that encloses the most cows with the current fence post and check if the fence is interesting.
- If the fence is interesting, increment the count of interesting fences.
- After checking all possible fences, return the count of interesting fences.
- The 'get_cows' function is changed to correctly calculate the number of cows enclosed by the fence using the Pick's theorem. The number of boundary points is calculated by checking the gcd of the differences in x and y coordinates of the fence posts.
- The 'is_interesting' function checks if a fence is interesting based on the number of enclosed cows and the area of the fence. If the number of enclosed cows is odd and the area of the fence is an integer, the fence is interesting.
- The fixed code will correctly count the number of interesting fences for the given input example.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-05 10:33:29.159 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict
from math import atan2
from fractions import gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:33:29.160 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:33:29.160 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:33:29.161 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,6 +1,7 @@
 import sys
 from collections import defaultdict
 from math import atan2
+from fractions import gcd
 
 def read_input():
     n = int(input().strip())
@@ -21,7 +22,10 @@
     return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)
 
 def get_cows(p1, p2, p3):
-    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) // 2)
+    # calculate the number of boundary points using gcd
+    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
+    # calculate the number of interior points using Pick's theorem
+    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)
 
 def is_interesting(p1, p2, p3):
     area = get_area(p1, p2, p3)

2023-11-05 10:33:33.073 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:33:33.073 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:33:33.073 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:33:33.073 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5
0 0
2 16
30 14
4 6
2 10

2023-11-05 10:33:33.073 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
---

2023-11-05 10:33:33.073 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kFailed, passed=False.  sandbox error:   File "<string>", line 4, in <module>
ImportError: cannot import name 'gcd' from 'fractions' (/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/fractions.py)
2023-11-05 10:33:33.074 | ERROR    | alpha_codium.gen.stages.run_tests:run_tests:31 - failed to run solution
2023-11-05 10:33:33.074 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:55 - counter: 2
2023-11-05 10:33:33.077 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:33:33.078 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:33:33.078 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:33:33.078 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'

self-reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

A Python solution code that was generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2
from fractions import gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'


However, when running the following input example, the code failed to produce the expected output:
'
File "<string>", line 4, in <module>
ImportError: cannot import name 'gcd' from 'fractions' (/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/fractions.py)
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-05 10:33:43.523 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '3\n0 0\n2 0\n0 4\n', expected_output: '1\n', code_output: 'ImportError: cannot import name \'gcd\' from \'fractions\' (/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/fractions.py)\n'}
what_went_wrong: |-
  The code failed because it tried to import the gcd function from the fractions module, but the gcd function is not in the fractions module. It is in the math module. This is a simple import error that can be fixed by changing the import statement to import gcd from the correct module.
input_output_fixed_flow: |-
  - Replace "from fractions import gcd" with "from math import gcd"
  - Run the code again with the corrected import statement
  - The code should now be able to correctly calculate the greatest common divisor (gcd) of two numbers using the gcd function from the math module
  - This will allow the get_cows function to correctly calculate the number of cows enclosed by the fence
  - The is_interesting function will then be able to correctly determine whether a fence is interesting based on the number of enclosed cows and the area of the fence
  - Finally, the count_interesting_fences function will correctly count the number of interesting fences and print the result
2023-11-05 10:33:43.524 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:33:43.524 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:33:43.533 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:33:43.533 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:33:43.533 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:33:43.533 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2
from fractions import gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
File "<string>", line 4, in <module>
ImportError: cannot import name 'gcd' from 'fractions' (/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/fractions.py)
'

what_went_wrong:
'
The code failed because it tried to import the gcd function from the fractions module, but the gcd function is not in the fractions module. It is in the math module. This is a simple import error that can be fixed by changing the import statement to import gcd from the correct module.
'

input_output_fixed_flow:
'
- Replace "from fractions import gcd" with "from math import gcd"
- Run the code again with the corrected import statement
- The code should now be able to correctly calculate the greatest common divisor (gcd) of two numbers using the gcd function from the math module
- This will allow the get_cows function to correctly calculate the number of cows enclosed by the fence
- The is_interesting function will then be able to correctly determine whether a fence is interesting based on the number of enclosed cows and the area of the fence
- Finally, the count_interesting_fences function will correctly count the number of interesting fences and print the result
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-05 10:34:03.997 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict
from math import atan2, gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:34:03.998 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:34:03.998 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:34:03.998 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,7 +1,6 @@
 import sys
 from collections import defaultdict
-from math import atan2
-from fractions import gcd
+from math import atan2, gcd
 
 def read_input():
     n = int(input().strip())

2023-11-05 10:34:07.855 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:34:07.856 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:34:07.856 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:34:07.856 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5
0 0
2 16
30 14
4 6
2 10

2023-11-05 10:34:07.856 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
---
16
2023-11-05 10:34:07.856 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-05 10:34:07.856 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:55 - counter: 3
2023-11-05 10:34:07.860 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:34:07.860 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:34:07.860 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:34:07.860 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'

self-reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

A Python solution code that was generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2, gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
5
0 0
2 16
30 14
4 6
2 10

expected output:
3
code output:
16
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-05 10:34:17.546 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "5\n0 0\n2 16\n30 14\n4 6\n2 10\n",
      "expected_output": "3\n",
      "code_output": "16\n"
    }
  ]
what_went_wrong: |-
  The main issue with the code is in the count_interesting_fences function. The code is incorrectly counting the number of interesting fences. It is iterating over all possible combinations of fence posts, but it is not correctly checking if a fence is interesting. The while loop inside the for loop is not correctly calculating the number of cows inside a fence. It is comparing the number of cows inside two different fences, which is not the correct way to check if a fence is interesting. Instead, it should check if the number of cows inside a single fence is odd and if the area of the fence is an integer.
input_output_fixed_flow: |-
  - Read the input data.
  - Sort the fence posts.
  - Iterate over all possible combinations of fence posts.
  - For each combination, calculate the area of the fence and the number of cows inside the fence.
  - Check if the number of cows is odd and if the area is an integer. If both conditions are met, the fence is interesting.
  - Count the number of interesting fences.
  - Print the count.
2023-11-05 10:34:17.547 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:34:17.547 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:34:17.554 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:34:17.554 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:34:17.554 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:34:17.554 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict
from math import atan2, gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def sort_posts(posts):
    posts.sort()
    return posts

def get_angle(p1, p2):
    return atan2(p2[1] - p1[1], p2[0] - p1[0])

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    posts = sort_posts(posts)
    interesting_fences = 0
    for i in range(n):
        angles = []
        for j in range(n):
            if i != j:
                angles.append((get_angle(posts[i], posts[j]), j))
        angles.sort()
        j = 0
        for k in range(n-1):
            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
                j = (j + 1) % (n - 1)
            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
                interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
5
0 0
2 16
30 14
4 6
2 10

expected output:
3
code output:
16
====================
====================
'

what_went_wrong:
'
The main issue with the code is in the count_interesting_fences function. The code is incorrectly counting the number of interesting fences. It is iterating over all possible combinations of fence posts, but it is not correctly checking if a fence is interesting. The while loop inside the for loop is not correctly calculating the number of cows inside a fence. It is comparing the number of cows inside two different fences, which is not the correct way to check if a fence is interesting. Instead, it should check if the number of cows inside a single fence is odd and if the area of the fence is an integer.
'

input_output_fixed_flow:
'
- Read the input data.
- Sort the fence posts.
- Iterate over all possible combinations of fence posts.
- For each combination, calculate the area of the fence and the number of cows inside the fence.
- Check if the number of cows is odd and if the area is an integer. If both conditions are met, the fence is interesting.
- Count the number of interesting fences.
- Print the count.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-05 10:34:31.125 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    interesting_fences = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                if is_interesting(posts[i], posts[j], posts[k]):
                    interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:34:31.125 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:34:31.125 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:34:31.125 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,7 +1,3 @@
-import sys
-from collections import defaultdict
-from math import atan2, gcd
-
 def read_input():
     n = int(input().strip())
     posts = []
@@ -9,13 +5,6 @@
         x, y = map(int, input().strip().split())
         posts.append((x, y))
     return n, posts
-
-def sort_posts(posts):
-    posts.sort()
-    return posts
-
-def get_angle(p1, p2):
-    return atan2(p2[1] - p1[1], p2[0] - p1[0])
 
 def get_area(p1, p2, p3):
     return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)
@@ -32,20 +21,12 @@
     return area.is_integer() and cows % 2 == 1
 
 def count_interesting_fences(n, posts):
-    posts = sort_posts(posts)
     interesting_fences = 0
     for i in range(n):
-        angles = []
-        for j in range(n):
-            if i != j:
-                angles.append((get_angle(posts[i], posts[j]), j))
-        angles.sort()
-        j = 0
-        for k in range(n-1):
-            while get_cows(posts[i], posts[angles[j][1]], posts[angles[(j+1)%(n-1)][1]]) < get_cows(posts[i], posts[angles[k][1]], posts[angles[(k+1)%(n-1)][1]]):
-                j = (j + 1) % (n - 1)
-            if is_interesting(posts[i], posts[angles[k][1]], posts[angles[j][1]]):
-                interesting_fences += 1
+        for j in range(i+1, n):
+            for k in range(j+1, n):
+                if is_interesting(posts[i], posts[j], posts[k]):
+                    interesting_fences += 1
     return interesting_fences
 
 if __name__ == "__main__":

2023-11-05 10:34:35.036 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:34:35.036 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:34:35.036 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:34:35.036 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5
0 0
2 16
30 14
4 6
2 10

2023-11-05 10:34:35.036 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
---

2023-11-05 10:34:35.036 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kFailed, passed=False.  sandbox error:   File "<string>", line 34, in <module>
  File "<string>", line 28, in count_interesting_fences
  File "<string>", line 20, in is_interesting
  File "<string>", line 14, in get_cows
NameError: name 'gcd' is not defined
2023-11-05 10:34:35.037 | ERROR    | alpha_codium.gen.stages.run_tests:run_tests:31 - failed to run solution
2023-11-05 10:34:35.037 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:55 - counter: 4
2023-11-05 10:34:35.040 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:34:35.041 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:34:35.041 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:34:35.041 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'

self-reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'

A Python solution code that was generated for the problem:
'
def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    interesting_fences = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                if is_interesting(posts[i], posts[j], posts[k]):
                    interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'


However, when running the following input example, the code failed to produce the expected output:
'
File "<string>", line 34, in <module>
  File "<string>", line 28, in count_interesting_fences
  File "<string>", line 20, in is_interesting
  File "<string>", line 14, in get_cows
NameError: name 'gcd' is not defined
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-05 10:34:46.720 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '5\n0 0\n2 16\n30 14\n4 6\n2 10\n', expected_output: '3\n', code_output: 'NameError: name \'gcd\' is not defined\n'}
what_went_wrong: |-
  The code failed because it uses the function 'gcd' which is not defined anywhere in the code. The 'gcd' function is used to calculate the greatest common divisor of two numbers. In Python, this function is available in the 'math' module. So, the error can be fixed by importing the 'gcd' function from the 'math' module.
input_output_fixed_flow: |-
  - The function 'read_input' reads the number of fence posts and their coordinates from the input.
  - The function 'get_area' calculates the area of a triangle formed by three fence posts.
  - The function 'get_cows' calculates the number of cows enclosed by the fence. It uses the 'gcd' function to calculate the number of boundary points. Then, it uses Pick's theorem to calculate the number of interior points.
  - The function 'is_interesting' checks if a fence is interesting. A fence is interesting if its area is an integer and it encloses an odd number of cows.
  - The function 'count_interesting_fences' counts the number of interesting fences. It iterates over all possible combinations of three fence posts and checks if the fence formed by these posts is interesting.
  - The 'gcd' function is imported from the 'math' module.
  - The 'count_interesting_fences' function is called with the number of fence posts and their coordinates as arguments. The result is printed.
2023-11-05 10:34:46.721 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:34:46.721 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:34:46.728 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 10:34:46.729 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 10:34:46.729 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 10:34:46.729 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
This is the easy version of the problem. The only difference from the hard version is that in this version all coordinates are even.

There are n fence-posts at distinct coordinates on a plane. It is guaranteed that no three fence posts lie on the same line.

There are an infinite number of cows on the plane, one at every point with integer coordinates.

Gregor is a member of the Illuminati, and wants to build a triangular fence, connecting 3 distinct existing fence posts. A cow strictly inside the fence is said to be enclosed. If there are an odd number of enclosed cows and the area of the fence is an integer, the fence is said to be interesting.

Find the number of interesting fences.

Input

The first line contains the integer n (3 ≤ n ≤ 6000), the number of fence posts which Gregor can choose to form the vertices of a fence.

Each of the next n line contains two integers x and y (0 ≤ x,y ≤ 10^7, x and y are even), where (x,y) is the coordinate of a fence post. All fence posts lie at distinct coordinates. No three fence posts are on the same line.

Output

Print a single integer, the number of interesting fences. Two fences are considered different if they are constructed with a different set of three fence posts.

Examples

Input


3
0 0
2 0
0 4


Output


1


Input


5
0 0
2 16
30 14
4 6
2 10


Output


3

Note

In the first example, there is only 1 fence. That fence is interesting since its area is 4 and there is 1 enclosed cow, marked in red.

<image>

In the second example, there are 3 interesting fences. 

  * (0,0) — (30,14) — (2,10) 
  * (2,16) — (30,14) — (2,10) 
  * (30,14) — (4,6) — (2,10)
'


self reflection on the problem:
'
- The problem is about Gregor who wants to build a triangular fence using the given fence posts.
- The fence posts are given as coordinates on a plane.
- The goal is to find the number of "interesting" fences that Gregor can build.
- A fence is considered "interesting" if it encloses an odd number of cows and its area is an integer.
- The input is the number of fence posts and their coordinates.
- The output is the number of "interesting" fences that Gregor can build.
- The constraints are that the number of fence posts is between 3 and 6000, and the coordinates of the fence posts are even integers between 0 and 10^7.
'


A solution code generated for the problem:
'
def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    # calculate the number of boundary points using gcd
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    # calculate the number of interior points using Pick's theorem
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    interesting_fences = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                if is_interesting(posts[i], posts[j], posts[k]):
                    interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
File "<string>", line 34, in <module>
  File "<string>", line 28, in count_interesting_fences
  File "<string>", line 20, in is_interesting
  File "<string>", line 14, in get_cows
NameError: name 'gcd' is not defined
'

what_went_wrong:
'
The code failed because it uses the function 'gcd' which is not defined anywhere in the code. The 'gcd' function is used to calculate the greatest common divisor of two numbers. In Python, this function is available in the 'math' module. So, the error can be fixed by importing the 'gcd' function from the 'math' module.
'

input_output_fixed_flow:
'
- The function 'read_input' reads the number of fence posts and their coordinates from the input.
- The function 'get_area' calculates the area of a triangle formed by three fence posts.
- The function 'get_cows' calculates the number of cows enclosed by the fence. It uses the 'gcd' function to calculate the number of boundary points. Then, it uses Pick's theorem to calculate the number of interior points.
- The function 'is_interesting' checks if a fence is interesting. A fence is interesting if its area is an integer and it encloses an odd number of cows.
- The function 'count_interesting_fences' counts the number of interesting fences. It iterates over all possible combinations of three fence posts and checks if the fence formed by these posts is interesting.
- The 'gcd' function is imported from the 'math' module.
- The 'count_interesting_fences' function is called with the number of fence posts and their coordinates as arguments. The result is printed.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-05 10:35:00.667 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
from math import gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    interesting_fences = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                if is_interesting(posts[i], posts[j], posts[k]):
                    interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:35:00.669 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 10:35:00.669 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 10:35:00.670 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,3 +1,5 @@
+from math import gcd
+
 def read_input():
     n = int(input().strip())
     posts = []
@@ -10,9 +12,7 @@
     return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)
 
 def get_cows(p1, p2, p3):
-    # calculate the number of boundary points using gcd
     boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
-    # calculate the number of interior points using Pick's theorem
     return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)
 
 def is_interesting(p1, p2, p3):

2023-11-05 10:35:04.550 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:35:04.550 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:35:04.550 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:35:04.550 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5
0 0
2 16
30 14
4 6
2 10

2023-11-05 10:35:04.551 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
---
3
2023-11-05 10:35:04.551 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 10:35:04.551 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:55 - counter: 5
2023-11-05 10:35:04.551 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:57 - Passed public tests after 4 attempts
2023-11-05 10:35:08.364 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:35:08.364 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:35:08.364 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:35:08.364 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
3
0 0
2 0
0 4

2023-11-05 10:35:08.364 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
1
---
1
2023-11-05 10:35:08.365 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 10:35:08.365 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:55 - counter: 1
2023-11-05 10:35:08.365 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:57 - Passed public tests after 0 attempts
2023-11-05 10:35:08.366 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:169 - testing solution on private tests with prediction:
from math import gcd

def read_input():
    n = int(input().strip())
    posts = []
    for _ in range(n):
        x, y = map(int, input().strip().split())
        posts.append((x, y))
    return n, posts

def get_area(p1, p2, p3):
    return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)

def get_cows(p1, p2, p3):
    boundary_points = gcd(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) + gcd(abs(p2[0] - p3[0]), abs(p2[1] - p3[1])) + gcd(abs(p3[0] - p1[0]), abs(p3[1] - p1[1]))
    return int(get_area(p1, p2, p3) - boundary_points / 2 + 1)

def is_interesting(p1, p2, p3):
    area = get_area(p1, p2, p3)
    cows = get_cows(p1, p2, p3)
    return area.is_integer() and cows % 2 == 1

def count_interesting_fences(n, posts):
    interesting_fences = 0
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                if is_interesting(posts[i], posts[j], posts[k]):
                    interesting_fences += 1
    return interesting_fences

if __name__ == "__main__":
    n, posts = read_input()
    print(count_interesting_fences(n, posts))
2023-11-05 10:35:12.249 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
20
200 716
88 526
434 134
996 890
718 220
820 462
614 178
848 208
724 536
124 710
408 228
846 606
222 32
642 180
694 964
438 994
718 524
688 692
126 494
102 116

2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
650
---
650
2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
12 10
6 14
2 6
6 12

2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
---
2
2023-11-05 10:35:12.250 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-1 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 10:35:12.251 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:201 - =====================================
2023-11-05 10:35:12.251 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:202 - test_passed: 2, test_failed: 0
2023-11-05 10:35:12.251 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:203 - =====================================

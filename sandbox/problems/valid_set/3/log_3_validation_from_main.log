2023-11-13 08:48:15.179 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:137 - problem_name: 1548_E. Gregor and the Two Painters
2023-11-13 08:48:15.182 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:140 - problem['cf_tags']: ['data structures', 'divide and conquer', 'graphs', 'greedy', 'math']
2023-11-13 08:48:15.184 | INFO     | alpha_codium.gen.coding_competitor:run:71 - Running code contests competitor, model gpt-4
2023-11-13 08:48:15.184 | INFO     | alpha_codium.gen.stages.utils:set_configurations:18 - recording_path: /Users/talrid/Git/alphaCodium/alpha_codium/gen/code_contests/1548_E. Gregor and the Two Painters/gpt-4/
do_record: True
use_record: False
2023-11-13 08:48:15.185 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:15 - --reflection stage--
2023-11-13 08:48:15.188 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:48:15.188 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:48:15.188 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:48:15.188 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1548_E. Gregor and the Two Painters'


problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples. Avoid simple greedy or brute force solutions.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): binary search, dynamic programming, trees, combinatorics, dfs, bfs, graphs, constructive algorithms, math, data structures, geometry, number theory, two pointers ..."")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=2, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-13 08:48:50.125 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
  - Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
  - A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
  - A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
  - The goal is to find the number of badly painted regions.
  - The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
  - The output is a single integer representing the number of badly painted regions.

possible_solutions:
- name: "Sort and Sweep Line Algorithm"
  content: |
    This solution involves sorting the rows and columns based on the number of paint layers and then using a sweep line algorithm to find the badly painted regions.
    - First, sort the rows and columns in ascending order based on the number of paint layers.
    - Then, initialize a counter for the number of badly painted regions and a sweep line that moves from the top-left to the bottom-right of the grid.
    - As the sweep line moves, check if the current cell is badly painted. If it is, increment the counter and continue to the next cell. If it is not, move the sweep line to the next row or column (whichever has fewer paint layers) and repeat the process.
    - Continue this process until the sweep line reaches the bottom-right of the grid.
    - The counter will then hold the number of badly painted regions.
  labels:
  - "sort"
  - "sweep line"
  complexity: |
    The time complexity is O(n log n + m log m) for sorting the rows and columns, and O(n + m) for the sweep line algorithm. The space complexity is O(n + m) for storing the sorted rows and columns.

- name: "Depth-First Search (DFS)"
  content: |
    This solution involves using a depth-first search (DFS) to find the badly painted regions.
    - First, create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
    - Then, initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
    - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell. In the DFS, visit all adjacent cells that are badly painted and have not been visited.
    - The counter will then hold the number of badly painted regions.
  labels:
  - "dfs"
  - "graphs"
  complexity: |
    The time complexity is O(n * m) for the DFS, and the space complexity is O(n * m) for the grid and the visited set.
2023-11-13 08:48:50.126 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:48:50.126 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:48:50.130 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:14 - --choose best solution stage--
2023-11-13 08:48:50.134 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:48:50.134 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:48:50.134 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:48:50.134 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'


self reflection:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'

possible solutions:
'
- name: "Sort and Sweep Line Algorithm"
  content: |
    This solution involves sorting the rows and columns based on the number of paint layers and then using a sweep line algorithm to find the badly painted regions.
    - First, sort the rows and columns in ascending order based on the number of paint layers.
    - Then, initialize a counter for the number of badly painted regions and a sweep line that moves from the top-left to the bottom-right of the grid.
    - As the sweep line moves, check if the current cell is badly painted. If it is, increment the counter and continue to the next cell. If it is not, move the sweep line to the next row or column (whichever has fewer paint layers) and repeat the process.
    - Continue this process until the sweep line reaches the bottom-right of the grid.
    - The counter will then hold the number of badly painted regions.
  labels:
  - "sort"
  - "sweep line"
  complexity: |
    The time complexity is O(n log n + m log m) for sorting the rows and columns, and O(n + m) for the sweep line algorithm. The space complexity is O(n + m) for storing the sorted rows and columns.

- name: "Depth-First Search (DFS)"
  content: |
    This solution involves using a depth-first search (DFS) to find the badly painted regions.
    - First, create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
    - Then, initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
    - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell. In the DFS, visit all adjacent cells that are badly painted and have not been visited.
    - The counter will then hold the number of badly painted regions.
  labels:
  - "dfs"
  - "graphs"
  complexity: |
    The time complexity is O(n * m) for the DFS, and the space complexity is O(n * m) for the grid and the visited set.
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class Test(BaseModel):
    input: str
    output: str

class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): binary search, dynamic programming, trees, combinatorics, dfs, bfs, graphs, constructive algorithms, math, data structures, geometry, number theory, two pointers,...")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    problem_tests: List[Test] = Field("list the input-output examples that are provided in the problem description. Sort them from easiest to hardest.")
    input_output_examples_flow: str = Field(description="describe in details how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
problem_tests: |
  - input: |
      ...
    output: |
      ...
  ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-13 08:49:21.576 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: "Depth-First Search (DFS)"
content: |
  This solution involves using a depth-first search (DFS) to find the badly painted regions.
  - First, create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
  - Then, initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
  - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell. In the DFS, visit all adjacent cells that are badly painted and have not been visited.
  - The counter will then hold the number of badly painted regions.
labels:
  - "dfs"
  - "graphs"
complexity: |
  The time complexity is O(n * m) for the DFS, and the space complexity is O(n * m) for the grid and the visited set.
why: |
  This solution is the best because it is simple, robust, and fully solves the problem. It uses a depth-first search, which is a common and well-understood algorithm for traversing or searching through a graph. This makes it easy to understand and implement. It also handles all edge cases, as it checks every cell in the grid and correctly counts the number of badly painted regions.
flow: |
  - Create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
  - Initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
  - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell.
  - In the DFS, visit all adjacent cells that are badly painted and have not been visited.
  - The counter will then hold the number of badly painted regions.
problem_tests:
  - input: |
      3 4 11
      9 8 5
      10 6 7 2
    output: |
      2
  - input: |
      3 4 12
      9 8 5
      10 6 7 2
    output: |
      1
  - input: |
      3 3 2
      1 2 1
      1 2 1
    output: |
      4
  - input: |
      5 23 6
      1 4 3 5 2
      2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5
    output: |
      6
input_output_examples_flow: |
  - For the first example, the grid is created with the total number of paint layers in each cell. Then, the DFS starts from the first cell and visits all adjacent cells that are badly painted and have not been visited. This process is repeated for all cells in the grid, resulting in a count of 2 badly painted regions.
  - For the second example, the same process is followed, but with a different maximum number of paint layers in a badly painted cell. This results in a count of 1 badly painted region.
  - For the third example, the process is repeated with a different grid and maximum number of paint layers, resulting in a count of 4 badly painted regions.
  - For the fourth example, the process is repeated with a larger grid and different number of paint layers, resulting in a count of 6 badly painted regions.
2023-11-13 08:49:21.576 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:49:21.577 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:49:21.582 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-13 08:49:21.587 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:49:21.587 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:49:21.587 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:49:21.587 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a proposed solution:

problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'


self-reflection:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'


proposed solution:
'
name: "Depth-First Search (DFS)"
content: |
  This solution involves using a depth-first search (DFS) to find the badly painted regions.
  - First, create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
  - Then, initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
  - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell. In the DFS, visit all adjacent cells that are badly painted and have not been visited.
  - The counter will then hold the number of badly painted regions.
labels:
  - "dfs"
  - "graphs"
complexity: |
  The time complexity is O(n * m) for the DFS, and the space complexity is O(n * m) for the grid and the visited set.
why: |
  This solution is the best because it is simple, robust, and fully solves the problem. It uses a depth-first search, which is a common and well-understood algorithm for traversing or searching through a graph. This makes it easy to understand and implement. It also handles all edge cases, as it checks every cell in the grid and correctly counts the number of badly painted regions.
flow: |
  - Create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
  - Initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
  - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell.
  - In the DFS, visit all adjacent cells that are badly painted and have not been visited.
  - The counter will then hold the number of badly painted regions.
problem_tests:
  - input: |
      3 4 11
      9 8 5
      10 6 7 2
    output: |
      2
  - input: |
      3 4 12
      9 8 5
      10 6 7 2
    output: |
      1
  - input: |
      3 3 2
      1 2 1
      1 2 1
    output: |
      4
  - input: |
      5 23 6
      1 4 3 5 2
      2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5
    output: |
      6
input_output_examples_flow: |
  - For the first example, the grid is created with the total number of paint layers in each cell. Then, the DFS starts from the first cell and visits all adjacent cells that are badly painted and have not been visited. This process is repeated for all cells in the grid, resulting in a count of 2 badly painted regions.
  - For the second example, the same process is followed, but with a different maximum number of paint layers in a badly painted cell. This results in a count of 1 badly painted region.
  - For the third example, the process is repeated with a different grid and maximum number of paint layers, resulting in a count of 4 badly painted regions.
  - For the fourth example, the process is repeated with a larger grid and different number of paint layers, resulting in a count of 6 badly painted regions.
'


Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the generated code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and simulate running it on the provided input-output examples. Follow the 'input_output_examples_flow' section.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- Make sure to follow the 'flow' and 'input_output_examples_flow' sections.

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

answer:
```python
2023-11-13 08:49:40.437 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
2023-11-13 08:49:40.438 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:49:40.438 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:49:40.439 | INFO     | alpha_codium.gen.stages.run_generate_ai_test:run_generate_ai_tests:13 - --generate ai tests stage--
2023-11-13 08:49:40.445 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:49:40.445 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:49:40.446 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:49:40.446 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a possible solution.

problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'


self reflection:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'

possible solution:
'
name: "Depth-First Search (DFS)"
content: |
  This solution involves using a depth-first search (DFS) to find the badly painted regions.
  - First, create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
  - Then, initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
  - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell. In the DFS, visit all adjacent cells that are badly painted and have not been visited.
  - The counter will then hold the number of badly painted regions.
labels:
  - "dfs"
  - "graphs"
complexity: |
  The time complexity is O(n * m) for the DFS, and the space complexity is O(n * m) for the grid and the visited set.
why: |
  This solution is the best because it is simple, robust, and fully solves the problem. It uses a depth-first search, which is a common and well-understood algorithm for traversing or searching through a graph. This makes it easy to understand and implement. It also handles all edge cases, as it checks every cell in the grid and correctly counts the number of badly painted regions.
flow: |
  - Create a 2D grid representing the ceiling, where each cell contains the total number of paint layers (a_i + b_j).
  - Initialize a counter for the number of badly painted regions and a visited set to keep track of the cells that have been visited.
  - For each cell in the grid, if it is badly painted and has not been visited, increment the counter and start a DFS from that cell.
  - In the DFS, visit all adjacent cells that are badly painted and have not been visited.
  - The counter will then hold the number of badly painted regions.
problem_tests:
  - input: |
      3 4 11
      9 8 5
      10 6 7 2
    output: |
      2
  - input: |
      3 4 12
      9 8 5
      10 6 7 2
    output: |
      1
  - input: |
      3 3 2
      1 2 1
      1 2 1
    output: |
      4
  - input: |
      5 23 6
      1 4 3 5 2
      2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5
    output: |
      6
input_output_examples_flow: |
  - For the first example, the grid is created with the total number of paint layers in each cell. Then, the DFS starts from the first cell and visits all adjacent cells that are badly painted and have not been visited. This process is repeated for all cells in the grid, resulting in a count of 2 badly painted regions.
  - For the second example, the same process is followed, but with a different maximum number of paint layers in a badly painted cell. This results in a count of 1 badly painted region.
  - For the third example, the process is repeated with a different grid and maximum number of paint layers, resulting in a count of 4 badly painted regions.
  - For the fourth example, the process is repeated with a larger grid and different number of paint layers, resulting in a count of 6 badly painted regions.
'

Your task is to generate 6 diverse input-output examples for the problem.
They should be sorted by difficulty, from easiest to hardest.
It is essential that all the inputs are valid, and the outputs are correct. Double check them, and validate they match the problem description and constraints.


The output must be a YAML object equivalent to type $ProblemTests, according to the following Pydantic definitions:
'
class Test(BaseModel):
    input: str
    output: str

class ProblemTests(BaseModel):
    tests: List[Test] = Field(min_items=6, max_items=6)
'


Example YAML output:
```yaml
tests:
- input: |
    ...
  output: |
    ...
...
```

Answer:
```yaml
2023-11-13 08:49:51.621 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
tests:
- input: |
    1 1 2
    1
    1
  output: |
    1
- input: |
    2 2 4
    2 1
    1 2
  output: |
    1
- input: |
    3 3 5
    2 3 1
    1 2 3
  output: |
    2
- input: |
    4 4 6
    3 2 1 4
    2 3 1 2
  output: |
    3
- input: |
    5 5 7
    3 2 1 4 2
    2 3 1 2 3
  output: |
    4
- input: |
    6 6 8
    4 3 2 1 4 2
    2 3 1 2 3 4
  output: |
    5

2023-11-13 08:49:51.625 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:49:51.625 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:49:51.630 | INFO     | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:16 - --run simple test stage--
2023-11-13 08:49:55.866 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:49:55.867 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:49:55.867 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:49:55.867 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
1 1 2
1
1

2023-11-13 08:49:55.867 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:49:55.867 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:49:55.867 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:49:55.867 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:49:55.868 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:19 - --iterate on public tests stage--
2023-11-13 08:50:00.147 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:00.147 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:00.147 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:00.147 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 11
9 8 5
10 6 7 2

2023-11-13 08:50:00.147 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
2
---
2
2023-11-13 08:50:00.148 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:00.148 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:00.148 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:00.148 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:72 - counter: 1
2023-11-13 08:50:00.148 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:74 - Passed public tests after 0 attempts
2023-11-13 08:50:04.388 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:04.388 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:04.388 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:04.388 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 12
9 8 5
10 6 7 2

2023-11-13 08:50:04.388 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:50:04.388 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:04.389 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:04.389 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:04.389 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:72 - counter: 1
2023-11-13 08:50:04.389 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:74 - Passed public tests after 0 attempts
2023-11-13 08:50:08.605 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:08.605 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:08.605 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:08.605 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 2
1 2 1
1 2 1

2023-11-13 08:50:08.605 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
4
---
4
2023-11-13 08:50:08.605 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:08.606 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:08.606 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:08.606 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:72 - counter: 1
2023-11-13 08:50:08.606 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:74 - Passed public tests after 0 attempts
2023-11-13 08:50:12.869 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:12.869 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:12.870 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:12.870 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5

2023-11-13 08:50:12.870 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
6
---
6
2023-11-13 08:50:12.870 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:12.870 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:12.870 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:12.870 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:72 - counter: 1
2023-11-13 08:50:12.870 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:74 - Passed public tests after 0 attempts
2023-11-13 08:50:12.870 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:130 - ==================
2023-11-13 08:50:12.870 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:131 - Passed all public tests
2023-11-13 08:50:12.870 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:132 - ==================
2023-11-13 08:50:12.871 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:19 - --iterate on all ai tests stage--
2023-11-13 08:50:17.160 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:17.160 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:17.160 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:17.160 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5

2023-11-13 08:50:17.160 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
6
---
6
2023-11-13 08:50:17.161 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:17.161 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:17.161 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:17.161 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-13 08:50:21.438 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:21.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:21.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:21.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 2
1 2 1
1 2 1

2023-11-13 08:50:21.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
4
---
4
2023-11-13 08:50:21.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:21.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:21.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:21.439 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-13 08:50:25.740 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:25.741 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:25.741 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:25.741 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 12
9 8 5
10 6 7 2

2023-11-13 08:50:25.741 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:50:25.741 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:25.741 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:25.741 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:25.741 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-13 08:50:30.005 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:30.005 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:30.005 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:30.005 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 11
9 8 5
10 6 7 2

2023-11-13 08:50:30.005 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
2
---
2
2023-11-13 08:50:30.005 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:30.006 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:30.006 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:30.006 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-13 08:50:34.265 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:34.265 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:34.265 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:34.265 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
1 1 2
1
1

2023-11-13 08:50:34.266 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:50:34.266 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:34.266 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:34.266 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:34.266 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-13 08:50:38.567 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:38.568 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:38.568 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:38.568 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
2 2 4
2 1
1 2

2023-11-13 08:50:38.568 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:50:38.568 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:50:38.568 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:50:38.568 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:38.569 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-13 08:50:42.751 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:50:42.751 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:50:42.751 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:50:42.752 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 5
2 3 1
1 2 3

2023-11-13 08:50:42.752 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
2
---
1
2023-11-13 08:50:42.752 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:50:42.752 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:50:42.752 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:50:42.752 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:53 - Failed to pass ai tests. trying to fix code
2023-11-13 08:50:42.756 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:50:42.756 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:50:42.756 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:50:42.756 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'

self-reflection on the problem:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'

A Python solution code that was generated for the problem:
'
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
'


However, when running the following input example, the Python code above failed to produce the expected output:
'
test input:
3 3 5
2 3 1
1 2 3

expected output:
2
code output:
1
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific and elaborate. Emphasize the fixed parts, and how do they apply to getting the correct output")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-13 08:51:01.202 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: "3 3 5\n2 3 1\n1 2 3\n", expected_output: "2\n", code_output: "1\n"}
what_went_wrong: |-
  The original code failed to correctly identify the badly painted regions. The problem lies in the way the grid is created and how the depth-first search (DFS) is performed. The code currently adds the paint layers of a row and a column to get the total paint layers in a cell. However, this approach does not consider the fact that the painters might not paint the cells in the same order. Therefore, the order of painting can affect the number of badly painted regions. The DFS also does not correctly identify the connected components of badly painted cells. It only checks the immediate neighbors of a cell, but it should also check the neighbors of those neighbors and so on, until it finds a cell that is not badly painted.
failed_test_fixed_flow: |-
  - First, sort the lists of paint layers applied by Amin and Benj in non-decreasing order. This ensures that the painters paint the cells in the same order.
  - Then, create two lists to store the prefix sums of the paint layers applied by Amin and Benj. This represents the total number of paint layers in each cell after both painters have painted it.
  - Next, iterate over the prefix sums and count the number of elements that are less than or equal to x. These are the badly painted cells.
  - Now, perform a DFS on the grid. Start from a badly painted cell and explore all its neighbors. If a neighbor is also badly painted and has not been visited yet, continue the DFS from that neighbor. Mark all visited cells.
  - Each DFS represents a connected component of badly painted cells, i.e., a badly painted region. Therefore, count the number of DFSs to get the number of badly painted regions.
  - Finally, return the number of badly painted regions.
2023-11-13 08:51:01.202 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:51:01.202 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:51:01.209 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:51:01.209 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:51:01.209 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:51:01.209 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'


self reflection on the problem:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'


A solution code generated for the problem:
'
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
3 3 5
2 3 1
1 2 3

expected output:
2
code output:
1
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The original code failed to correctly identify the badly painted regions. The problem lies in the way the grid is created and how the depth-first search (DFS) is performed. The code currently adds the paint layers of a row and a column to get the total paint layers in a cell. However, this approach does not consider the fact that the painters might not paint the cells in the same order. Therefore, the order of painting can affect the number of badly painted regions. The DFS also does not correctly identify the connected components of badly painted cells. It only checks the immediate neighbors of a cell, but it should also check the neighbors of those neighbors and so on, until it finds a cell that is not badly painted.
'

failed_test_fixed_flow:
'
- First, sort the lists of paint layers applied by Amin and Benj in non-decreasing order. This ensures that the painters paint the cells in the same order.
- Then, create two lists to store the prefix sums of the paint layers applied by Amin and Benj. This represents the total number of paint layers in each cell after both painters have painted it.
- Next, iterate over the prefix sums and count the number of elements that are less than or equal to x. These are the badly painted cells.
- Now, perform a DFS on the grid. Start from a badly painted cell and explore all its neighbors. If a neighbor is also badly painted and has not been visited yet, continue the DFS from that neighbor. Mark all visited cells.
- Each DFS represents a connected component of badly painted cells, i.e., a badly painted region. Therefore, count the number of DFSs to get the number of badly painted regions.
- Finally, return the number of badly painted regions.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-13 08:51:17.374 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def sort_and_prefix_sum(a, b):
    a.sort()
    b.sort()
    prefix_sum_a = [0] * len(a)
    prefix_sum_b = [0] * len(b)
    prefix_sum_a[0] = a[0]
    prefix_sum_b[0] = b[0]
    for i in range(1, len(a)):
        prefix_sum_a[i] = prefix_sum_a[i - 1] + a[i]
    for i in range(1, len(b)):
        prefix_sum_b[i] = prefix_sum_b[i - 1] + b[i]
    return prefix_sum_a, prefix_sum_b

def count_badly_painted_cells(x, prefix_sum_a, prefix_sum_b):
    count_a = sum(1 for ai in prefix_sum_a if ai <= x)
    count_b = sum(1 for bj in prefix_sum_b if bj <= x)
    return count_a, count_b

def count_badly_painted_regions(count_a, count_b):
    return min(count_a, count_b)

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    prefix_sum_a, prefix_sum_b = sort_and_prefix_sum(a, b)
    count_a, count_b = count_badly_painted_cells(x, prefix_sum_a, prefix_sum_b)
    result = count_badly_painted_regions(count_a, count_b)
    print(result)
2023-11-13 08:51:17.375 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:51:17.375 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:51:17.376 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:33 - diff:
--- 
+++ 
@@ -4,39 +4,30 @@
     b = list(map(int, input().split()))
     return n, m, x, a, b
 
-def create_grid(n, m, a, b):
-    grid = [[0]*m for _ in range(n)]
-    for i in range(n):
-        for j in range(m):
-            grid[i][j] = a[i] + b[j]
-    return grid
+def sort_and_prefix_sum(a, b):
+    a.sort()
+    b.sort()
+    prefix_sum_a = [0] * len(a)
+    prefix_sum_b = [0] * len(b)
+    prefix_sum_a[0] = a[0]
+    prefix_sum_b[0] = b[0]
+    for i in range(1, len(a)):
+        prefix_sum_a[i] = prefix_sum_a[i - 1] + a[i]
+    for i in range(1, len(b)):
+        prefix_sum_b[i] = prefix_sum_b[i - 1] + b[i]
+    return prefix_sum_a, prefix_sum_b
 
-def is_badly_painted(cell, x):
-    return cell <= x
+def count_badly_painted_cells(x, prefix_sum_a, prefix_sum_b):
+    count_a = sum(1 for ai in prefix_sum_a if ai <= x)
+    count_b = sum(1 for bj in prefix_sum_b if bj <= x)
+    return count_a, count_b
 
-def is_valid(i, j, n, m):
-    return 0 <= i < n and 0 <= j < m
-
-def dfs(i, j, n, m, grid, x, visited):
-    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
-    visited.add((i, j))
-    for dx, dy in directions:
-        ni, nj = i + dx, j + dy
-        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
-            dfs(ni, nj, n, m, grid, x, visited)
-
-def count_badly_painted_regions(n, m, x, grid):
-    visited = set()
-    count = 0
-    for i in range(n):
-        for j in range(m):
-            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
-                count += 1
-                dfs(i, j, n, m, grid, x, visited)
-    return count
+def count_badly_painted_regions(count_a, count_b):
+    return min(count_a, count_b)
 
 if __name__ == "__main__":
     n, m, x, a, b = read_input()
-    grid = create_grid(n, m, a, b)
-    result = count_badly_painted_regions(n, m, x, grid)
+    prefix_sum_a, prefix_sum_b = sort_and_prefix_sum(a, b)
+    count_a, count_b = count_badly_painted_cells(x, prefix_sum_a, prefix_sum_b)
+    result = count_badly_painted_regions(count_a, count_b)
     print(result)
2023-11-13 08:51:21.798 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:51:21.798 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:51:21.798 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:51:21.799 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 5
2 3 1
1 2 3

2023-11-13 08:51:21.799 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
2
---
2
2023-11-13 08:51:21.799 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:51:21.799 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:51:21.799 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.116 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:51:26.117 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:51:26.117 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:51:26.117 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 11
9 8 5
10 6 7 2

2023-11-13 08:51:26.117 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
2
---
1
2023-11-13 08:51:26.117 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:26.117 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 12
9 8 5
10 6 7 2

2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-1 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 2
1 2 1
1 2 1

2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
4
---
2
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-2 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:26.118 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5

2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
6
---
3
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-3 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5

2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
6
---
3
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-4 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:26.119 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 2
1 2 1
1 2 1

2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
4
---
2
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-5 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 12
9 8 5
10 6 7 2

2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-6 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.120 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 4 11
9 8 5
10 6 7 2

2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
2
---
1
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-7 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
1 1 2
1
1

2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-8 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
2 2 4
2 1
1 2

2023-11-13 08:51:26.121 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
2
2023-11-13 08:51:26.122 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-9 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:26.122 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:26.122 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:26.122 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:77 - The fix broke prev passed tests. reverting to last solution
2023-11-13 08:51:30.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:51:30.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:51:30.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:51:30.439 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
4 4 6
3 2 1 4
2 3 1 2

2023-11-13 08:51:30.440 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
3
---
1
2023-11-13 08:51:30.440 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:51:30.440 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:51:30.440 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:51:30.440 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:53 - Failed to pass ai tests. trying to fix code
2023-11-13 08:51:30.445 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:51:30.445 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:51:30.445 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:51:30.445 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'

self-reflection on the problem:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'

A Python solution code that was generated for the problem:
'
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
'


However, when running the following input example, the Python code above failed to produce the expected output:
'
test input:
4 4 6
3 2 1 4
2 3 1 2

expected output:
3
code output:
1
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific and elaborate. Emphasize the fixed parts, and how do they apply to getting the correct output")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-13 08:51:45.668 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '4 4 6\n3 2 1 4\n2 3 1 2\n', expected_output: '3\n', code_output: '1\n'}
what_went_wrong: |-
  The problem with the code solution is that it incorrectly calculates the number of badly painted regions. The code uses a depth-first search (DFS) to find connected components of badly painted cells, but it does not correctly handle the case where a cell is adjacent to a cell that is not badly painted. The DFS should stop when it encounters a cell that is not badly painted, but the current implementation does not do this. As a result, the code incorrectly counts the number of badly painted regions.
failed_test_fixed_flow: |-
  - Read the input values.
  - Create a grid that represents the ceiling, with each cell containing the total number of paint layers applied by Amin and Benj.
  - Initialize a set to keep track of visited cells and a counter to keep track of the number of badly painted regions.
  - Iterate over each cell in the grid.
  - If the cell is badly painted and has not been visited, increment the counter and start a DFS from the cell.
  - In the DFS, visit the cell and then visit all its adjacent cells that are badly painted and have not been visited. If an adjacent cell is not badly painted, stop the DFS for that direction.
  - After iterating over all the cells, the counter will contain the number of badly painted regions. Print this number.
2023-11-13 08:51:45.669 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:51:45.669 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:51:45.676 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:51:45.677 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:51:45.677 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:51:45.677 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'


self reflection on the problem:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'


A solution code generated for the problem:
'
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
4 4 6
3 2 1 4
2 3 1 2

expected output:
3
code output:
1
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The problem with the code solution is that it incorrectly calculates the number of badly painted regions. The code uses a depth-first search (DFS) to find connected components of badly painted cells, but it does not correctly handle the case where a cell is adjacent to a cell that is not badly painted. The DFS should stop when it encounters a cell that is not badly painted, but the current implementation does not do this. As a result, the code incorrectly counts the number of badly painted regions.
'

failed_test_fixed_flow:
'
- Read the input values.
- Create a grid that represents the ceiling, with each cell containing the total number of paint layers applied by Amin and Benj.
- Initialize a set to keep track of visited cells and a counter to keep track of the number of badly painted regions.
- Iterate over each cell in the grid.
- If the cell is badly painted and has not been visited, increment the counter and start a DFS from the cell.
- In the DFS, visit the cell and then visit all its adjacent cells that are badly painted and have not been visited. If an adjacent cell is not badly painted, stop the DFS for that direction.
- After iterating over all the cells, the counter will contain the number of badly painted regions. Print this number.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-13 08:52:03.752 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m, grid, x):
    return 0 <= i < n and 0 <= j < m and is_badly_painted(grid[i][j], x)

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m, grid, x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
2023-11-13 08:52:03.752 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:52:03.753 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:52:03.754 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:33 - diff:
--- 
+++ 
@@ -14,15 +14,15 @@
 def is_badly_painted(cell, x):
     return cell <= x
 
-def is_valid(i, j, n, m):
-    return 0 <= i < n and 0 <= j < m
+def is_valid(i, j, n, m, grid, x):
+    return 0 <= i < n and 0 <= j < m and is_badly_painted(grid[i][j], x)
 
 def dfs(i, j, n, m, grid, x, visited):
     directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
     visited.add((i, j))
     for dx, dy in directions:
         ni, nj = i + dx, j + dy
-        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
+        if is_valid(ni, nj, n, m, grid, x) and (ni, nj) not in visited:
             dfs(ni, nj, n, m, grid, x, visited)
 
 def count_badly_painted_regions(n, m, x, grid):

2023-11-13 08:52:08.069 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:52:08.070 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:52:08.070 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:52:08.070 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
4 4 6
3 2 1 4
2 3 1 2

2023-11-13 08:52:08.070 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
3
---
1
2023-11-13 08:52:08.070 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:52:08.070 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:52:08.070 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:52:08.070 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:67 - Failed to pass ai tests after trying to fix code. reverting to last solution
2023-11-13 08:52:12.245 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:52:12.246 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:52:12.246 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:52:12.246 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
5 5 7
3 2 1 4 2
2 3 1 2 3

2023-11-13 08:52:12.246 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
4
---
1
2023-11-13 08:52:12.246 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:52:12.246 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:52:12.246 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:52:12.246 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:53 - Failed to pass ai tests. trying to fix code
2023-11-13 08:52:12.250 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:52:12.250 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:52:12.250 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:52:12.251 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'

self-reflection on the problem:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'

A Python solution code that was generated for the problem:
'
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
'


However, when running the following input example, the Python code above failed to produce the expected output:
'
test input:
5 5 7
3 2 1 4 2
2 3 1 2 3

expected output:
4
code output:
1
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific and elaborate. Emphasize the fixed parts, and how do they apply to getting the correct output")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-13 08:52:31.172 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '5 5 7\n3 2 1 4 2\n2 3 1 2 3\n', expected_output: '4\n', code_output: '1\n'}
what_went_wrong: |-
  The problem with the code solution is that it doesn't correctly identify all the badly painted regions. The issue lies in the depth-first search (DFS) function. The DFS function is supposed to explore all the connected cells that are badly painted. However, in the current implementation, it only explores the cells that are adjacent and badly painted. This means that if a badly painted cell is surrounded by well-painted cells, it will not be explored, and therefore, it will not be counted as a separate badly painted region. This is why the code fails to produce the correct output for the provided input example.
failed_test_fixed_flow: |-
  - Read the input values.
  - Create the grid by adding the number of paint layers applied by Amin and Benj to each cell.
  - Initialize a set to keep track of the visited cells and a counter to count the number of badly painted regions.
  - Iterate over each cell in the grid. If a cell is badly painted and has not been visited yet, increment the counter and start a DFS from this cell.
  - In the DFS function, mark the current cell as visited. Then, for each adjacent cell, if it is valid, badly painted, and has not been visited yet, recursively call the DFS function on it.
  - However, unlike the original code, the DFS function should also explore the cells that are not adjacent but are still connected through other badly painted cells. This can be achieved by adding a condition in the DFS function to continue exploring as long as the current cell is badly painted, regardless of whether it is adjacent to the starting cell or not.
  - Finally, print the count of badly painted regions.
2023-11-13 08:52:31.173 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:52:31.174 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:52:31.191 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-13 08:52:31.191 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-13 08:52:31.191 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-13 08:52:31.192 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
Two painters, Amin and Benj, are repainting Gregor's living room ceiling! The ceiling can be modeled as an n × m grid.

For each i between 1 and n, inclusive, painter Amin applies a_i layers of paint to the entire i-th row. For each j between 1 and m, inclusive, painter Benj applies b_j layers of paint to the entire j-th column. Therefore, the cell (i,j) ends up with a_i+b_j layers of paint.

Gregor considers the cell (i,j) to be badly painted if a_i+b_j ≤ x. Define a badly painted region to be a maximal connected component of badly painted cells, i. e. a connected component of badly painted cells such that all adjacent to the component cells are not badly painted. Two cells are considered adjacent if they share a side.

Gregor is appalled by the state of the finished ceiling, and wants to know the number of badly painted regions.

Input

The first line contains three integers n, m and x (1 ≤ n,m ≤ 2⋅ 10^5, 1 ≤ x ≤ 2⋅ 10^5) — the dimensions of Gregor's ceiling, and the maximum number of paint layers in a badly painted cell.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2⋅ 10^5), the number of paint layers Amin applies to each row.

The third line contains m integers b_1, b_2, …, b_m (1 ≤ b_j ≤ 2⋅ 10^5), the number of paint layers Benj applies to each column.

Output

Print a single integer, the number of badly painted regions.

Examples

Input


3 4 11
9 8 5
10 6 7 2


Output


2


Input


3 4 12
9 8 5
10 6 7 2


Output


1


Input


3 3 2
1 2 1
1 2 1


Output


4


Input


5 23 6
1 4 3 5 2
2 3 1 6 1 5 5 6 1 3 2 6 2 3 1 6 1 4 1 6 1 5 5


Output


6

Note

The diagram below represents the first example. The numbers to the left of each row represent the list a, and the numbers above each column represent the list b. The numbers inside each cell represent the number of paint layers in that cell.

The colored cells correspond to badly painted cells. The red and blue cells respectively form 2 badly painted regions.

<image>
'


self reflection on the problem:
'
- The problem is about two painters, Amin and Benj, who are painting a ceiling that can be represented as an n x m grid.
- Amin paints each row i with a_i layers of paint, and Benj paints each column j with b_j layers of paint. As a result, each cell (i,j) ends up with a_i + b_j layers of paint.
- A cell is considered badly painted if the total number of paint layers (a_i + b_j) is less than or equal to x.
- A badly painted region is defined as a maximal connected component of badly painted cells, where all adjacent cells are not badly painted. Cells are considered adjacent if they share a side.
- The goal is to find the number of badly painted regions.
- The input consists of the dimensions of the ceiling (n, m), the maximum number of paint layers in a badly painted cell (x), the number of paint layers Amin applies to each row (a_1, a_2, ..., a_n), and the number of paint layers Benj applies to each column (b_1, b_2, ..., b_m).
- The output is a single integer representing the number of badly painted regions.
'


A solution code generated for the problem:
'
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
5 5 7
3 2 1 4 2
2 3 1 2 3

expected output:
4
code output:
1
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The problem with the code solution is that it doesn't correctly identify all the badly painted regions. The issue lies in the depth-first search (DFS) function. The DFS function is supposed to explore all the connected cells that are badly painted. However, in the current implementation, it only explores the cells that are adjacent and badly painted. This means that if a badly painted cell is surrounded by well-painted cells, it will not be explored, and therefore, it will not be counted as a separate badly painted region. This is why the code fails to produce the correct output for the provided input example.
'

failed_test_fixed_flow:
'
- Read the input values.
- Create the grid by adding the number of paint layers applied by Amin and Benj to each cell.
- Initialize a set to keep track of the visited cells and a counter to count the number of badly painted regions.
- Iterate over each cell in the grid. If a cell is badly painted and has not been visited yet, increment the counter and start a DFS from this cell.
- In the DFS function, mark the current cell as visited. Then, for each adjacent cell, if it is valid, badly painted, and has not been visited yet, recursively call the DFS function on it.
- However, unlike the original code, the DFS function should also explore the cells that are not adjacent but are still connected through other badly painted cells. This can be achieved by adding a condition in the DFS function to continue exploring as long as the current cell is badly painted, regardless of whether it is adjacent to the starting cell or not.
- Finally, print the count of badly painted regions.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-13 08:52:48.399 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    stack = [(i, j)]
    while stack:
        i, j = stack.pop()
        visited.add((i, j))
        for dx, dy in directions:
            ni, nj = i + dx, j + dy
            if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
                stack.append((ni, nj))

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
2023-11-13 08:52:48.400 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-13 08:52:48.400 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-13 08:52:48.401 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:33 - diff:
--- 
+++ 
@@ -19,11 +19,14 @@
 
 def dfs(i, j, n, m, grid, x, visited):
     directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
-    visited.add((i, j))
-    for dx, dy in directions:
-        ni, nj = i + dx, j + dy
-        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
-            dfs(ni, nj, n, m, grid, x, visited)
+    stack = [(i, j)]
+    while stack:
+        i, j = stack.pop()
+        visited.add((i, j))
+        for dx, dy in directions:
+            ni, nj = i + dx, j + dy
+            if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
+                stack.append((ni, nj))
 
 def count_badly_painted_regions(n, m, x, grid):
     visited = set()

2023-11-13 08:52:52.891 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:52:52.892 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:52:52.892 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:52:52.892 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
5 5 7
3 2 1 4 2
2 3 1 2 3

2023-11-13 08:52:52.892 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
4
---
1
2023-11-13 08:52:52.892 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:52:52.892 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:52:52.892 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:52:52.893 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:67 - Failed to pass ai tests after trying to fix code. reverting to last solution
2023-11-13 08:52:57.224 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:52:57.224 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:52:57.224 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:52:57.225 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
6 6 8
4 3 2 1 4 2
2 3 1 2 3 4

2023-11-13 08:52:57.225 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
5
---
1
2023-11-13 08:52:57.225 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=None
2023-11-13 08:52:57.225 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=None. 
2023-11-13 08:52:57.225 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:52:57.225 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:50 - Failed to pass ai test. reached max number of calls
2023-11-13 08:52:57.226 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:126 - testing solution on private tests with prediction:
def read_input():
    n, m, x = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    return n, m, x, a, b

def create_grid(n, m, a, b):
    grid = [[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            grid[i][j] = a[i] + b[j]
    return grid

def is_badly_painted(cell, x):
    return cell <= x

def is_valid(i, j, n, m):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, n, m, grid, x, visited):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited.add((i, j))
    for dx, dy in directions:
        ni, nj = i + dx, j + dy
        if is_valid(ni, nj, n, m) and is_badly_painted(grid[ni][nj], x) and (ni, nj) not in visited:
            dfs(ni, nj, n, m, grid, x, visited)

def count_badly_painted_regions(n, m, x, grid):
    visited = set()
    count = 0
    for i in range(n):
        for j in range(m):
            if is_badly_painted(grid[i][j], x) and (i, j) not in visited:
                count += 1
                dfs(i, j, n, m, grid, x, visited)
    return count

if __name__ == "__main__":
    n, m, x, a, b = read_input()
    grid = create_grid(n, m, a, b)
    result = count_badly_painted_regions(n, m, x, grid)
    print(result)
2023-11-13 08:53:01.455 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:87 - compilation results:ProgramStatus.kSuccess
2023-11-13 08:53:01.455 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:89 - 
2023-11-13 08:53:01.455 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:90 - 
2023-11-13 08:53:01.455 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
1 1 2
1
1

2023-11-13 08:53:01.455 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:53:01.455 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
1 1 1
1
1

2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
0
---
0
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-1 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 4
2 3 2
3 2 2

2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
2
---
2
2023-11-13 08:53:01.456 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-2 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
5 5 6
1 2 3 4 5
5 4 3 2 1

2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-3 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:97 - input:
3 3 7
3 4 3
3 4 3

2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:98 - expected vs code output:
1
---
1
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:111 - test-4 :: status=ProgramStatus.kSuccess, passed=True
2023-11-13 08:53:01.457 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:115 - passed=True
2023-11-13 08:53:01.458 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:116 - =====================================================================
2023-11-13 08:53:01.458 | INFO     | alpha_codium.gen.coding_competitor:evaluate_on_private_tests:184 - =====================================
2023-11-13 08:53:01.458 | INFO     | alpha_codium.gen.coding_competitor:evaluate_on_private_tests:185 - test_passed: 5, test_failed: 0
2023-11-13 08:53:01.458 | INFO     | alpha_codium.gen.coding_competitor:evaluate_on_private_tests:186 - =====================================

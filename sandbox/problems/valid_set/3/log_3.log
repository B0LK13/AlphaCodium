2023-11-05 12:28:00.550 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:179 - problem_name: 1549_A. Gregor and Cryptography
2023-11-05 12:28:00.554 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:182 - problem['cf_tags']: ['math', 'number theory']
2023-11-05 12:28:00.556 | INFO     | alpha_codium.gen.coding_competitor:run:70 - Running code contests competitor, model gpt-4
2023-11-05 12:28:00.557 | INFO     | alpha_codium.gen.stages.utils:set_configurations:17 - recording_path: /Users/talrid/Git/alphaCodium/alpha_codium/gen/code_contests/1549_A. Gregor and Cryptography/gpt-4/
do_record: True
use_record: False
2023-11-05 12:28:00.558 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:15 - --reflection stage--
2023-11-05 12:28:00.561 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 12:28:00.561 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 12:28:00.561 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 12:28:00.561 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1549_A. Gregor and Cryptography'


problem description:
'
Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.

Gregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.

  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and 
  * 2 ≤ a < b ≤ P. 



Help Gregor find two bases of his favorite prime number!

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000).

Each subsequent line contains the integer P (5 ≤ P ≤ {10}^9), with P guaranteed to be prime.

Output

Your output should consist of t lines. Each line should consist of two integers a and b (2 ≤ a < b ≤ P). If there are multiple possible solutions, print any.

Example

Input


2
17
5


Output


3 5
2 4

Note

The first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.

In the second query, with P=5, the only solution is a=2 and b=4.
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=3, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-05 12:28:18.425 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem is about helping Gregor find two bases of his favorite prime number.
  - Gregor's favorite prime number is denoted as P.
  - The two bases, a and b, should satisfy two conditions: P mod a = P mod b, and 2 ≤ a < b ≤ P.
  - The input consists of multiple test cases. The first line of the input contains the number of test cases, t. Each subsequent line contains the integer P.
  - The output should consist of t lines. Each line should consist of two integers a and b.
  - If there are multiple possible solutions, any can be printed.

possible_solutions:
- name: Brute Force
  content: |
    Iterate over all pairs of numbers (a, b) such that 2 ≤ a < b ≤ P. For each pair, check if P mod a = P mod b. If it does, print the pair and break the loop. This solution is simple but not efficient, especially for large values of P.
  labels:
  - Brute Force
  complexity: |
    The time complexity is O(P^2) because in the worst case we need to check all pairs of numbers (a, b). The space complexity is O(1) as we only need a constant amount of space to store the current pair (a, b).

- name: Mathematical Insight
  content: |
    We can observe that for any prime number P, P mod (P-1) = 1 and P mod 2 = 1. So, we can always choose a = 2 and b = P-1 as the two bases. This solution is very efficient as it does not require any iteration.
  labels:
  - Mathematics
  complexity: |
    The time complexity is O(1) as we only need to perform a constant number of operations. The space complexity is also O(1) as we only need a constant amount of space to store the two bases.

- name: Optimized Brute Force
  content: |
    We can optimize the brute force solution by observing that if P mod a = P mod b, then a and b must be divisors of P. Since P is a prime number, its only divisors are 1 and P itself. So, we can choose a = 2 and b = P. This solution is more efficient than the brute force solution but less efficient than the mathematical insight solution.
  labels:
  - Optimization
  - Brute Force
  complexity: |
    The time complexity is O(1) as we only need to perform a constant number of operations. The space complexity is also O(1) as we only need a constant amount of space to store the two bases.
2023-11-05 12:28:18.426 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 12:28:18.426 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 12:28:18.431 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:13 - --choose best solution stage--
2023-11-05 12:28:18.436 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 12:28:18.436 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 12:28:18.436 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 12:28:18.436 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem description:
'
Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.

Gregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.

  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and 
  * 2 ≤ a < b ≤ P. 



Help Gregor find two bases of his favorite prime number!

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000).

Each subsequent line contains the integer P (5 ≤ P ≤ {10}^9), with P guaranteed to be prime.

Output

Your output should consist of t lines. Each line should consist of two integers a and b (2 ≤ a < b ≤ P). If there are multiple possible solutions, print any.

Example

Input


2
17
5


Output


3 5
2 4

Note

The first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.

In the second query, with P=5, the only solution is a=2 and b=4.
'


self reflection:
'
- The problem is about helping Gregor find two bases of his favorite prime number.
- Gregor's favorite prime number is denoted as P.
- The two bases, a and b, should satisfy two conditions: P mod a = P mod b, and 2 ≤ a < b ≤ P.
- The input consists of multiple test cases. The first line of the input contains the number of test cases, t. Each subsequent line contains the integer P.
- The output should consist of t lines. Each line should consist of two integers a and b.
- If there are multiple possible solutions, any can be printed.
'

possible solutions:
'
- name: Brute Force
  content: |
    Iterate over all pairs of numbers (a, b) such that 2 ≤ a < b ≤ P. For each pair, check if P mod a = P mod b. If it does, print the pair and break the loop. This solution is simple but not efficient, especially for large values of P.
  labels:
  - Brute Force
  complexity: |
    The time complexity is O(P^2) because in the worst case we need to check all pairs of numbers (a, b). The space complexity is O(1) as we only need a constant amount of space to store the current pair (a, b).

- name: Mathematical Insight
  content: |
    We can observe that for any prime number P, P mod (P-1) = 1 and P mod 2 = 1. So, we can always choose a = 2 and b = P-1 as the two bases. This solution is very efficient as it does not require any iteration.
  labels:
  - Mathematics
  complexity: |
    The time complexity is O(1) as we only need to perform a constant number of operations. The space complexity is also O(1) as we only need a constant amount of space to store the two bases.

- name: Optimized Brute Force
  content: |
    We can optimize the brute force solution by observing that if P mod a = P mod b, then a and b must be divisors of P. Since P is a prime number, its only divisors are 1 and P itself. So, we can choose a = 2 and b = P. This solution is more efficient than the brute force solution but less efficient than the mathematical insight solution.
  labels:
  - Optimization
  - Brute Force
  complexity: |
    The time complexity is O(1) as we only need to perform a constant number of operations. The space complexity is also O(1) as we only need a constant amount of space to store the two bases.
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way.
Be critical - the provided solutions might be wrong, or not fully solve the problem.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): brute force, binary search, dynamic programming, trees, greedy, combinatorics, dfs, bfs, graphs, constructive algorithms, math, data structures, geometry, number theory, ...")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    input_output_examples_flow: str = Field(description="describe how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-05 12:28:31.579 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: Mathematical Insight
content: |
  We can observe that for any prime number P, P mod (P-1) = 1 and P mod 2 = 1. So, we can always choose a = 2 and b = P-1 as the two bases. This solution is very efficient as it does not require any iteration.
labels:
  - Mathematics
complexity: |
  The time complexity is O(1) as we only need to perform a constant number of operations. The space complexity is also O(1) as we only need a constant amount of space to store the two bases.
why: |
  This solution is the best because it is simple, efficient, and robust. It does not require any iteration or complex calculations, making it very fast and easy to implement. It also works for all prime numbers, making it a robust solution that can handle all possible inputs. Furthermore, it is based on a mathematical insight about prime numbers, which makes it a very elegant solution.
flow: |
  - Observe that for any prime number P, P mod (P-1) = 1 and P mod 2 = 1.
  - Therefore, we can always choose a = 2 and b = P-1 as the two bases.
  - Print the pair (a, b).
input_output_examples_flow: |
  - For the first example, P = 17. According to our solution, we choose a = 2 and b = 17 - 1 = 16. We can check that 17 mod 2 = 17 mod 16 = 1, so (2, 16) is a valid pair of bases.
  - For the second example, P = 5. According to our solution, we choose a = 2 and b = 5 - 1 = 4. We can check that 5 mod 2 = 5 mod 4 = 1, so (2, 4) is a valid pair of bases.
2023-11-05 12:28:31.580 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 12:28:31.580 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 12:28:31.584 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-05 12:28:31.590 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 12:28:31.590 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 12:28:31.590 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 12:28:31.591 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a proposed solution:

problem description:
'
Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.

Gregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.

  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and 
  * 2 ≤ a < b ≤ P. 



Help Gregor find two bases of his favorite prime number!

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000).

Each subsequent line contains the integer P (5 ≤ P ≤ {10}^9), with P guaranteed to be prime.

Output

Your output should consist of t lines. Each line should consist of two integers a and b (2 ≤ a < b ≤ P). If there are multiple possible solutions, print any.

Example

Input


2
17
5


Output


3 5
2 4

Note

The first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.

In the second query, with P=5, the only solution is a=2 and b=4.
'

self-reflection:
'
- The problem is about helping Gregor find two bases of his favorite prime number.
- Gregor's favorite prime number is denoted as P.
- The two bases, a and b, should satisfy two conditions: P mod a = P mod b, and 2 ≤ a < b ≤ P.
- The input consists of multiple test cases. The first line of the input contains the number of test cases, t. Each subsequent line contains the integer P.
- The output should consist of t lines. Each line should consist of two integers a and b.
- If there are multiple possible solutions, any can be printed.

'

proposed solution:
'
name: Mathematical Insight
content: |
  We can observe that for any prime number P, P mod (P-1) = 1 and P mod 2 = 1. So, we can always choose a = 2 and b = P-1 as the two bases. This solution is very efficient as it does not require any iteration.
labels:
  - Mathematics
complexity: |
  The time complexity is O(1) as we only need to perform a constant number of operations. The space complexity is also O(1) as we only need a constant amount of space to store the two bases.
why: |
  This solution is the best because it is simple, efficient, and robust. It does not require any iteration or complex calculations, making it very fast and easy to implement. It also works for all prime numbers, making it a robust solution that can handle all possible inputs. Furthermore, it is based on a mathematical insight about prime numbers, which makes it a very elegant solution.
flow: |
  - Observe that for any prime number P, P mod (P-1) = 1 and P mod 2 = 1.
  - Therefore, we can always choose a = 2 and b = P-1 as the two bases.
  - Print the pair (a, b).
input_output_examples_flow: |
  - For the first example, P = 17. According to our solution, we choose a = 2 and b = 17 - 1 = 16. We can check that 17 mod 2 = 17 mod 16 = 1, so (2, 16) is a valid pair of bases.
  - For the second example, P = 5. According to our solution, we choose a = 2 and b = 5 - 1 = 4. We can check that 5 mod 2 = 5 mod 4 = 1, so (2, 4) is a valid pair of bases.
'


Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and simulate running it on the provided input-output examples. Follow the 'input_output_examples_flow' section.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- Note that Python is a zero-indexed language. However, the problem description might use one-indexed values. Make sure to address this issue.

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

answer:
```python
2023-11-05 12:28:34.944 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def find_bases(P):
    a = 2
    b = P - 1
    return a, b

def solve_test_cases():
    t = int(input())
    for _ in range(t):
        P = int(input())
        a, b = find_bases(P)
        print(a, b)

if __name__ == "__main__":
    solve_test_cases()
2023-11-05 12:28:34.945 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 12:28:34.945 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 12:28:34.946 | INFO     | alpha_codium.gen.stages.run_generate_ai_test:run_generate_ai_tests:13 - --generate ai tests stage--
2023-11-05 12:28:34.951 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-05 12:28:34.951 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-05 12:28:34.951 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-05 12:28:34.951 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem and a self-reflection on the problem.

problem description:
'
Gregor is learning about RSA cryptography, and although he doesn't understand how RSA works, he is now fascinated with prime numbers and factoring them.

Gregor's favorite prime number is P. Gregor wants to find two bases of P. Formally, Gregor is looking for two integers a and b which satisfy both of the following properties.

  * P mod a = P mod b, where x mod y denotes the remainder when x is divided by y, and 
  * 2 ≤ a < b ≤ P. 



Help Gregor find two bases of his favorite prime number!

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000).

Each subsequent line contains the integer P (5 ≤ P ≤ {10}^9), with P guaranteed to be prime.

Output

Your output should consist of t lines. Each line should consist of two integers a and b (2 ≤ a < b ≤ P). If there are multiple possible solutions, print any.

Example

Input


2
17
5


Output


3 5
2 4

Note

The first query is P=17. a=3 and b=5 are valid bases in this case, because 17 mod 3 = 17 mod 5 = 2. There are other pairs which work as well.

In the second query, with P=5, the only solution is a=2 and b=4.
'


self reflection:
'
- The problem is about helping Gregor find two bases of his favorite prime number.
- Gregor's favorite prime number is denoted as P.
- The two bases, a and b, should satisfy two conditions: P mod a = P mod b, and 2 ≤ a < b ≤ P.
- The input consists of multiple test cases. The first line of the input contains the number of test cases, t. Each subsequent line contains the integer P.
- The output should consist of t lines. Each line should consist of two integers a and b.
- If there are multiple possible solutions, any can be printed.
'

Your task is to generate 6 additional input-output examples for the problem.
They should be sorted by difficulty, from easiest to hardest. The easiest test should be the chosen as the easiest one among the examples given in the problem description.
It is essential that all the outputs are correct. Double check them, and validate they match the problem description and constraints.

The output must be a YAML object equivalent to type $ProblemTests, according to the following Pydantic definitions:
'
class Test(BaseModel):
    input: str
    output: str

class ProblemTests(BaseModel):
    tests: List[Test] = Field(min_items=6, max_items=6)
'


Example YAML output:
```yaml
tests:
- input: |
    ...
  output: |
    ...
...
```

Answer:
```yaml
2023-11-05 12:28:41.893 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
tests:
- input: |
    1
    5
  output: |
    2 4
- input: |
    1
    7
  output: |
    2 5
- input: |
    1
    11
  output: |
    2 8
- input: |
    2
    13
    17
  output: |
    2 11
    3 5
- input: |
    3
    19
    23
    29
  output: |
    2 16
    3 8
    2 26
- input: |
    3
    31
    37
    41
  output: |
    2 28
    3 11
    2 38
2023-11-05 12:28:41.893 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-05 12:28:41.893 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-05 12:28:41.897 | INFO     | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:20 - --run simple test stage--
2023-11-05 12:28:45.871 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 12:28:45.872 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 12:28:45.872 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 12:28:45.872 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
5

2023-11-05 12:28:45.872 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2 4
---
2 4
2023-11-05 12:28:45.872 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 12:28:45.873 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:19 - --iterate on public tests stage--
2023-11-05 12:28:49.789 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 12:28:49.790 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 12:28:49.790 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 12:28:49.790 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
2
17
5

2023-11-05 12:28:49.790 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2 16
2 4
---
2 16
2 4
2023-11-05 12:28:49.790 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 12:28:49.790 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:57 - counter: 1
2023-11-05 12:28:49.790 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:59 - Passed public tests after 0 attempts
2023-11-05 12:28:49.791 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:168 - testing solution on private tests with prediction:
def find_bases(P):
    a = 2
    b = P - 1
    return a, b

def solve_test_cases():
    t = int(input())
    for _ in range(t):
        P = int(input())
        a, b = find_bases(P)
        print(a, b)

if __name__ == "__main__":
    solve_test_cases()
2023-11-05 12:28:53.793 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
2
17
5

2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2 16
2 4
---
2 16
2 4
2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
55439

2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2 55438
---
2 55438
2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-1 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 12:28:53.794 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5
5
7
11
13
19

2023-11-05 12:28:53.795 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2 4
2 6
2 10
2 12
2 18
---
2 4
2 6
2 10
2 12
2 18
2023-11-05 12:28:53.795 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-2 :: status=ProgramStatus.kSuccess, passed=True
2023-11-05 12:28:53.795 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:203 - =====================================
2023-11-05 12:28:53.795 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:204 - test_passed: 3, test_failed: 0
2023-11-05 12:28:53.795 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:205 - =====================================

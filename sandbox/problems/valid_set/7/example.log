2023-11-04 17:22:11.342 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:248 - problem_name: 1549_D. Integers Have Friends
2023-11-04 17:22:11.345 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:251 - problem['cf_tags']: ['binary search', 'data structures', 'math', 'two pointers']
2023-11-04 17:22:11.348 | INFO     | alpha_codium.gen.coding_competitor:run:68 - Running code contests competitor, model gpt-4
2023-11-04 17:22:11.348 | INFO     | alpha_codium.gen.stages.utils:set_configurations:16 - recording_path: ./code_contests/1549_D. Integers Have Friends/gpt-4/
do_record: True
use_record: False
2023-11-04 17:22:11.348 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:13 - --reflection stage--
2023-11-04 17:22:11.351 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:22:11.352 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:22:11.352 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:22:11.352 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1549_D. Integers Have Friends'


problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=3, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-04 17:22:27.598 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
  - The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
  - The output should be the size of the largest group of integers that share the same remainder for each test case.
  - The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.

possible_solutions:
- name: Brute Force
  content: |
    Iterate over all possible values of m from 2 to the maximum number in the array. For each m, calculate the remainder of each number in the array and group them by the remainder. The size of the largest group is the answer. This solution is very slow and will not work for large inputs.
  labels:
  - Brute Force
  complexity: |
    O(n^2) because for each number in the array, we are iterating over all other numbers.

- name: Sorting and Counting
  content: |
    Sort the array in ascending order. Iterate over the array and for each number, calculate the remainder of the division by all numbers less than it and count the number of equal remainders. The maximum count is the answer. This solution is faster than the brute force but still not optimal.
  labels:
  - Sorting
  - Counting
  complexity: |
    O(n log n) for sorting the array and O(n^2) for the counting, so the total complexity is O(n^2).

- name: Optimized Counting
  content: |
    Sort the array in ascending order. For each number, calculate the remainders of the division by all numbers less than it and keep track of the maximum count of equal remainders. Use a prefix sum array to optimize the counting. This solution is the most efficient.
  labels:
  - Sorting
  - Counting
  - Prefix Sum
  complexity: |
    O(n log n) for sorting the array and O(n) for the counting, so the total complexity is O(n log n).
2023-11-04 17:22:27.599 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:22:27.599 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:22:27.605 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:13 - --choose best solution stage--
2023-11-04 17:22:27.612 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:22:27.613 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:22:27.613 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:22:27.613 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem name: '1549_D. Integers Have Friends'


problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'


self reflection:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'

possible solutions:
'
- name: Brute Force
  content: |
    Iterate over all possible values of m from 2 to the maximum number in the array. For each m, calculate the remainder of each number in the array and group them by the remainder. The size of the largest group is the answer. This solution is very slow and will not work for large inputs.
  labels:
  - Brute Force
  complexity: |
    O(n^2) because for each number in the array, we are iterating over all other numbers.

- name: Sorting and Counting
  content: |
    Sort the array in ascending order. Iterate over the array and for each number, calculate the remainder of the division by all numbers less than it and count the number of equal remainders. The maximum count is the answer. This solution is faster than the brute force but still not optimal.
  labels:
  - Sorting
  - Counting
  complexity: |
    O(n log n) for sorting the array and O(n^2) for the counting, so the total complexity is O(n^2).

- name: Optimized Counting
  content: |
    Sort the array in ascending order. For each number, calculate the remainders of the division by all numbers less than it and keep track of the maximum count of equal remainders. Use a prefix sum array to optimize the counting. This solution is the most efficient.
  labels:
  - Sorting
  - Counting
  - Prefix Sum
  complexity: |
    O(n log n) for sorting the array and O(n) for the counting, so the total complexity is O(n log n).
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way.
Be critical - the provided solutions might be wrong, or not fully solve the problem.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): brute force, binary search, dynamic programming, trees, greedy, combinatorics, dfs, bfs, graphs, constructive algorithms, math, data structures, geometry, number theory, ...")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    input_output_examples_flow: str = Field(description="describe how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-04 17:22:51.347 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: Optimized Counting
content: |
  Sort the array in ascending order. For each number, calculate the remainders of the division by all numbers less than it and keep track of the maximum count of equal remainders. Use a prefix sum array to optimize the counting. This solution is the most efficient.
labels:
  - Sorting
  - Counting
  - Prefix Sum
complexity: O(n log n)
why: |
  This solution is the best because it fully solves the problem and does so efficiently. It uses sorting and counting, which are simple and robust methods. It also uses a prefix sum array to optimize the counting, which makes it more efficient than the other solutions. The complexity of this solution is O(n log n), which is reasonable and will run in less than 3 seconds on a modern computer for the given constraints.
flow: |
  - Sort the array in ascending order.
  - Initialize a prefix sum array with the same size as the input array.
  - Iterate over the array. For each number, calculate the remainders of the division by all numbers less than it.
  - Update the prefix sum array based on the count of equal remainders.
  - Keep track of the maximum count of equal remainders.
  - The maximum count is the size of the largest friend group.
input_output_examples_flow: |
  - For the first example, the sorted array is [1,2,4,5,6]. The remainders of the division by all numbers less than each number are [0,0,0,1,2,0,1,2,0,1]. The maximum count of equal remainders is 3, so the size of the largest friend group is 3.
  - For the second example, the sorted array is [2,5,8,10]. The remainders of the division by all numbers less than each number are [0,1,0,2,0,1,2,0]. The maximum count of equal remainders is 3, so the size of the largest friend group is 3.
  - For the third example, the sorted array is [1000,2000]. The remainders of the division by all numbers less than each number are [0,0]. The maximum count of equal remainders is 2, so the size of the largest friend group is 2.
  - For the fourth example, the sorted array is [3,12,45,54,55,78,234,465]. The remainders of the division by all numbers less than each number are [0,0,0,1,2,0,1,2,0,1,2,0,1,2,0,1]. The maximum count of equal remainders is 6, so the size of the largest friend group is 6.
2023-11-04 17:22:51.347 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:22:51.348 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:22:51.352 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-04 17:22:51.358 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:22:51.359 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:22:51.359 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:22:51.359 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a proposed solution:

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self-reflection:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.

'

propose solution:
'
name: Optimized Counting
content: |
  Sort the array in ascending order. For each number, calculate the remainders of the division by all numbers less than it and keep track of the maximum count of equal remainders. Use a prefix sum array to optimize the counting. This solution is the most efficient.
labels:
  - Sorting
  - Counting
  - Prefix Sum
complexity: O(n log n)
why: |
  This solution is the best because it fully solves the problem and does so efficiently. It uses sorting and counting, which are simple and robust methods. It also uses a prefix sum array to optimize the counting, which makes it more efficient than the other solutions. The complexity of this solution is O(n log n), which is reasonable and will run in less than 3 seconds on a modern computer for the given constraints.
flow: |
  - Sort the array in ascending order.
  - Initialize a prefix sum array with the same size as the input array.
  - Iterate over the array. For each number, calculate the remainders of the division by all numbers less than it.
  - Update the prefix sum array based on the count of equal remainders.
  - Keep track of the maximum count of equal remainders.
  - The maximum count is the size of the largest friend group.
input_output_examples_flow: |
  - For the first example, the sorted array is [1,2,4,5,6]. The remainders of the division by all numbers less than each number are [0,0,0,1,2,0,1,2,0,1]. The maximum count of equal remainders is 3, so the size of the largest friend group is 3.
  - For the second example, the sorted array is [2,5,8,10]. The remainders of the division by all numbers less than each number are [0,1,0,2,0,1,2,0]. The maximum count of equal remainders is 3, so the size of the largest friend group is 3.
  - For the third example, the sorted array is [1000,2000]. The remainders of the division by all numbers less than each number are [0,0]. The maximum count of equal remainders is 2, so the size of the largest friend group is 2.
  - For the fourth example, the sorted array is [3,12,45,54,55,78,234,465]. The remainders of the division by all numbers less than each number are [0,0,0,1,2,0,1,2,0,1,2,0,1,2,0,1]. The maximum count of equal remainders is 6, so the size of the largest friend group is 6.
'


Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- emphasis not accessing an index that is out of the range of a list

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

answer:
```python
2023-11-04 17:23:04.224 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    prefix_sum = [0] * (n + 10)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
2023-11-04 17:23:04.225 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:23:04.225 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:23:04.226 | INFO     | alpha_codium.gen.stages.run_generate_ai_test:run_generate_ai_tests:13 - --generate ai tests stage--
2023-11-04 17:23:04.232 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:23:04.232 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:23:04.233 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:23:04.233 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem and a  self-reflection on the problem.

problem name: '1549_D. Integers Have Friends'


problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'


self reflection:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'

Your task is to generate five input-output examples for the problem.
They should be sorted by difficulty, from easiest to hardest.
It is essential that all the outputs are correct. Double check them, and validate they match the problem description and constraints.

The output must be a YAML object equivalent to type $ProblemTests, according to the following Pydantic definitions:
'
class Test(BaseModel):
    input: str
    output: str

class ProblemTests(BaseModel):
    tests: List[Test] = Field(min_items=5, max_items=5)
'


Example YAML output:
```yaml
tests:
- input: |
    ...
  output: |
    ...
...
```

Answer:
```yaml
2023-11-04 17:23:14.130 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
tests:
- input: |
    1
    3
    3 6 9
  output: |
    3
- input: |
    1
    5
    5 10 15 20 25
  output: |
    5
- input: |
    2
    4
    4 8 12 16
    5
    5 10 15 20 25
  output: |
    4
    5
- input: |
    3
    4
    4 8 12 16
    5
    5 10 15 20 25
    6
    6 12 18 24 30 36
  output: |
    4
    5
    6
- input: |
    4
    4
    4 8 12 16
    5
    5 10 15 20 25
    6
    6 12 18 24 30 36
    7
    7 14 21 28 35 42 49
  output: |
    4
    5
    6
    7
2023-11-04 17:23:14.131 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:23:14.131 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:23:14.135 | INFO     | alpha_codium.gen.coding_competitor:run:91 - --iterate on public tests stage--
2023-11-04 17:23:14.152 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:23:14.152 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:23:14.152 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:23:14.152 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

2023-11-04 17:23:14.152 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
3
2
6
---
10
4
2023-11-04 17:23:14.152 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kFailed, passed=False.  sandbox error:   File "<string>", line 37, in <module>
  File "<string>", line 24, in find_largest_friend_group
IndexError: list index out of range
2023-11-04 17:23:14.152 | ERROR    | alpha_codium.gen.stages.run_tests:run_tests:31 - failed to run solution
2023-11-04 17:23:14.153 | INFO     | alpha_codium.gen.coding_competitor:run:127 - counter: 1
2023-11-04 17:23:14.158 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:23:14.158 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:23:14.158 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:23:14.158 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self-reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'

A solution code that was generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    prefix_sum = [0] * (n + 10)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the following input example, the code failed to produce the expected output:
'
File "<string>", line 37, in <module>
  File "<string>", line 24, in find_largest_friend_group
IndexError: list index out of range
'


Your goal is to analyze the code and the error, find the problem in the code, and propose a fix so the code will pass the input example.
Offer a fix that will keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-04 17:23:31.083 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 12 45 78\n', expected_output: '3\n3\n2\n6\n', code_output: 'IndexError: list index out of range'}
what_went_wrong: |-
  The problem with the code solution is that it tries to access an index of the prefix_sum list that is out of range. This happens because the prefix_sum list is initialized with a size of n + 10, but the code tries to access an index that is equal to a value in the array a, which can be much larger than n + 10. To fix this issue, the prefix_sum list should be initialized with a size that is large enough to accommodate the largest possible index that the code might try to access. Since the values in the array a can be up to 10^18, the prefix_sum list should be initialized with a size of 10^18 + 10.
input_output_fixed_flow: |-
  - Read the input and parse it into the number of test cases and a list of test cases.
  - For each test case, sort the array a.
  - Initialize the prefix_sum list with a size of 10^18 + 10.
  - Use a defaultdict to keep track of the count of each remainder when the numbers in the array a are divided by a certain number.
  - Iterate over the array a and for each number, calculate its remainder when divided by all the numbers that are less than or equal to it and update the count of each remainder in the defaultdict.
  - Keep track of the maximum group size by comparing it with the sum of the count of the current remainder and the prefix sum of the current number minus 1.
  - Update the prefix sum of the current number and the prefix sum of the current number minus 1.
  - Reset the count of the current number in the defaultdict to 0.
  - Print the maximum group size for each test case.
2023-11-04 17:23:31.084 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:23:31.084 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:23:31.093 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:23:31.093 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:23:31.093 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:23:31.093 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    prefix_sum = [0] * (n + 10)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the input-output example test, the code failed to produce the expected output.
Using the provided analysis, you need generate a fixed solution code, that will pass all the tests.

Error message when running the 'solution code':
'
File "<string>", line 37, in <module>
  File "<string>", line 24, in find_largest_friend_group
IndexError: list index out of range
'

what_went_wrong:
'
The problem with the code solution is that it tries to access an index of the prefix_sum list that is out of range. This happens because the prefix_sum list is initialized with a size of n + 10, but the code tries to access an index that is equal to a value in the array a, which can be much larger than n + 10. To fix this issue, the prefix_sum list should be initialized with a size that is large enough to accommodate the largest possible index that the code might try to access. Since the values in the array a can be up to 10^18, the prefix_sum list should be initialized with a size of 10^18 + 10.
'

input_output_fixed_flow:
'
- Read the input and parse it into the number of test cases and a list of test cases.
- For each test case, sort the array a.
- Initialize the prefix_sum list with a size of 10^18 + 10.
- Use a defaultdict to keep track of the count of each remainder when the numbers in the array a are divided by a certain number.
- Iterate over the array a and for each number, calculate its remainder when divided by all the numbers that are less than or equal to it and update the count of each remainder in the defaultdict.
- Keep track of the maximum group size by comparing it with the sum of the count of the current remainder and the prefix sum of the current number minus 1.
- Update the prefix sum of the current number and the prefix sum of the current number minus 1.
- Reset the count of the current number in the defaultdict to 0.
- Print the maximum group size for each test case.
'

guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-04 17:23:42.470 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    # Initialize prefix_sum with a size of 10^18 + 10 to avoid index out of range error
    prefix_sum = [0] * (10**18 + 10)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
2023-11-04 17:23:42.471 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:23:42.471 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:23:42.472 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -12,7 +12,8 @@
 
 def find_largest_friend_group(n, a):
     a.sort()
-    prefix_sum = [0] * (n + 10)
+    # Initialize prefix_sum with a size of 10^18 + 10 to avoid index out of range error
+    prefix_sum = [0] * (10**18 + 10)
     count = defaultdict(int)
     max_group_size = 1
     for i in range(n):

2023-11-04 17:23:42.485 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:23:42.485 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:23:42.485 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:23:42.486 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

2023-11-04 17:23:42.486 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
3
2
6
---

2023-11-04 17:23:42.486 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kFailed, passed=False.  sandbox error:   File "<string>", line 38, in <module>
  File "<string>", line 16, in find_largest_friend_group
MemoryError
2023-11-04 17:23:42.486 | ERROR    | alpha_codium.gen.stages.run_tests:run_tests:31 - failed to run solution
2023-11-04 17:23:42.486 | INFO     | alpha_codium.gen.coding_competitor:run:127 - counter: 2
2023-11-04 17:23:42.492 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:23:42.492 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:23:42.492 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:23:42.492 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self-reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'

A solution code that was generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    # Initialize prefix_sum with a size of 10^18 + 10 to avoid index out of range error
    prefix_sum = [0] * (10**18 + 10)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the following input example, the code failed to produce the expected output:
'
File "<string>", line 38, in <module>
  File "<string>", line 16, in find_largest_friend_group
MemoryError
'


Your goal is to analyze the code and the error, find the problem in the code, and propose a fix so the code will pass the input example.
Offer a fix that will keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-04 17:23:58.101 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 12 45 78\n', expected_output: '3\n3\n2\n6\n', code_output: 'MemoryError'}
what_went_wrong: |-
  The problem with the code solution is that it tries to create a list of size 10^18 + 10, which is not feasible due to memory limitations. This results in a MemoryError. The prefix_sum list is used to keep track of the maximum group size for each possible modulus. However, since the modulus is calculated as a[i] % a[j], where a[i] and a[j] are elements of the array a, the maximum possible modulus is the maximum element in a, not 10^18. Therefore, the size of the prefix_sum list should be reduced to the maximum element in a plus 1.
input_output_fixed_flow: |-
  - Read the input.
  - For each test case, sort the array a.
  - Initialize the prefix_sum list with a size of the maximum element in a plus 1.
  - Initialize a dictionary count to keep track of the number of elements with the same modulus.
  - Initialize max_group_size to 1.
  - Iterate over the array a. For each element a[i], calculate the modulus of all elements a[j] (j >= i) that are less than n units away from a[i] with respect to a[i]. Update count and max_group_size accordingly.
  - Update prefix_sum based on count.
  - Reset count for the next modulus.
  - Return max_group_size.
  - Print the result for each test case.
2023-11-04 17:23:58.101 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:23:58.101 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:23:58.111 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:23:58.111 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:23:58.112 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:23:58.112 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    # Initialize prefix_sum with a size of 10^18 + 10 to avoid index out of range error
    prefix_sum = [0] * (10**18 + 10)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the input-output example test, the code failed to produce the expected output.
Using the provided analysis, you need generate a fixed solution code, that will pass all the tests.

Error message when running the 'solution code':
'
File "<string>", line 38, in <module>
  File "<string>", line 16, in find_largest_friend_group
MemoryError
'

what_went_wrong:
'
The problem with the code solution is that it tries to create a list of size 10^18 + 10, which is not feasible due to memory limitations. This results in a MemoryError. The prefix_sum list is used to keep track of the maximum group size for each possible modulus. However, since the modulus is calculated as a[i] % a[j], where a[i] and a[j] are elements of the array a, the maximum possible modulus is the maximum element in a, not 10^18. Therefore, the size of the prefix_sum list should be reduced to the maximum element in a plus 1.
'

input_output_fixed_flow:
'
- Read the input.
- For each test case, sort the array a.
- Initialize the prefix_sum list with a size of the maximum element in a plus 1.
- Initialize a dictionary count to keep track of the number of elements with the same modulus.
- Initialize max_group_size to 1.
- Iterate over the array a. For each element a[i], calculate the modulus of all elements a[j] (j >= i) that are less than n units away from a[i] with respect to a[i]. Update count and max_group_size accordingly.
- Update prefix_sum based on count.
- Reset count for the next modulus.
- Return max_group_size.
- Print the result for each test case.
'

guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-04 17:24:10.777 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    # Initialize prefix_sum with a size of max(a) + 1 to avoid index out of range error
    prefix_sum = [0] * (max(a) + 1)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
2023-11-04 17:24:10.777 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:24:10.778 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:24:10.778 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -12,8 +12,8 @@
 
 def find_largest_friend_group(n, a):
     a.sort()
-    # Initialize prefix_sum with a size of 10^18 + 10 to avoid index out of range error
-    prefix_sum = [0] * (10**18 + 10)
+    # Initialize prefix_sum with a size of max(a) + 1 to avoid index out of range error
+    prefix_sum = [0] * (max(a) + 1)
     count = defaultdict(int)
     max_group_size = 1
     for i in range(n):

2023-11-04 17:24:10.781 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:24:10.782 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:24:10.782 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:24:10.782 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

2023-11-04 17:24:10.782 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
3
2
6
---
10
4
2
8
2023-11-04 17:24:10.782 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-04 17:24:10.782 | INFO     | alpha_codium.gen.coding_competitor:run:127 - counter: 3
2023-11-04 17:24:10.790 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:24:10.790 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:24:10.790 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:24:10.790 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self-reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'

A solution code that was generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    # Initialize prefix_sum with a size of max(a) + 1 to avoid index out of range error
    prefix_sum = [0] * (max(a) + 1)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

expected output:
3
3
2
6
code output:
10
4
2
8
====================
====================
'


Your goal is to analyze the code and the error, find the problem in the code, and propose a fix so the code will pass the input example.
Offer a fix that will keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-04 17:24:24.019 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 12 45 78\n",
      "expected_output": "3\n3\n2\n6\n",
      "code_output": "10\n4\n2\n8\n"
    }
  ]
what_went_wrong: |-
  The problem with the code solution is in the logic of the function find_largest_friend_group. The code is trying to find the largest friend group by checking the remainder of each number in the array when divided by the smallest number in the array. However, this approach is incorrect because the smallest number in the array is not necessarily the number that will yield the largest friend group. The correct approach should be to find the number that yields the largest friend group by checking the remainder of each number in the array when divided by all numbers from 2 to the maximum number in the array.
input_output_fixed_flow: |-
  - Read the input data.
  - For each test case, sort the array in ascending order.
  - Initialize a dictionary to store the count of each remainder when each number in the array is divided by all numbers from 2 to the maximum number in the array.
  - For each number in the array, calculate the remainder when it is divided by all numbers from 2 to the maximum number in the array, and increment the count of the remainder in the dictionary.
  - Find the maximum count in the dictionary, which represents the size of the largest friend group.
  - Print the size of the largest friend group for each test case.
2023-11-04 17:24:24.019 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:24:24.019 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:24:24.029 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:24:24.029 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:24:24.030 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:24:24.030 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    # Initialize prefix_sum with a size of max(a) + 1 to avoid index out of range error
    prefix_sum = [0] * (max(a) + 1)
    count = defaultdict(int)
    max_group_size = 1
    for i in range(n):
        if i > 0 and a[i] == a[i - 1]:
            continue
        j = i
        while j < n and a[j] - a[i] < n:
            count[a[j] % a[i]] += 1
            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
            j += 1
        while i < j:
            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
            if a[i] > 1:
                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
            count[a[i]] = 0
            i += 1
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the input-output example test, the code failed to produce the expected output.
Using the provided analysis, you need generate a fixed solution code, that will pass all the tests.

Error message when running the 'solution code':
'
test input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

expected output:
3
3
2
6
code output:
10
4
2
8
====================
====================
'

what_went_wrong:
'
The problem with the code solution is in the logic of the function find_largest_friend_group. The code is trying to find the largest friend group by checking the remainder of each number in the array when divided by the smallest number in the array. However, this approach is incorrect because the smallest number in the array is not necessarily the number that will yield the largest friend group. The correct approach should be to find the number that yields the largest friend group by checking the remainder of each number in the array when divided by all numbers from 2 to the maximum number in the array.
'

input_output_fixed_flow:
'
- Read the input data.
- For each test case, sort the array in ascending order.
- Initialize a dictionary to store the count of each remainder when each number in the array is divided by all numbers from 2 to the maximum number in the array.
- For each number in the array, calculate the remainder when it is divided by all numbers from 2 to the maximum number in the array, and increment the count of the remainder in the dictionary.
- Find the maximum count in the dictionary, which represents the size of the largest friend group.
- Print the size of the largest friend group for each test case.
'

guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-04 17:24:32.469 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, max_a + 1):
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
2023-11-04 17:24:32.469 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:24:32.469 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:24:32.470 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -12,24 +12,18 @@
 
 def find_largest_friend_group(n, a):
     a.sort()
-    # Initialize prefix_sum with a size of max(a) + 1 to avoid index out of range error
-    prefix_sum = [0] * (max(a) + 1)
-    count = defaultdict(int)
-    max_group_size = 1
-    for i in range(n):
-        if i > 0 and a[i] == a[i - 1]:
-            continue
+    max_a = a[-1]
+    count = [0] * (max_a + 1)
+    for i in a:
+        count[i] += 1
+    max_group_size = max(count)
+    for i in range(2, max_a + 1):
         j = i
-        while j < n and a[j] - a[i] < n:
-            count[a[j] % a[i]] += 1
-            max_group_size = max(max_group_size, count[a[j] % a[i]] + prefix_sum[a[i] - 1])
-            j += 1
-        while i < j:
-            prefix_sum[a[i]] = max(prefix_sum[a[i]], count[a[i]])
-            if a[i] > 1:
-                prefix_sum[a[i] - 1] = max(prefix_sum[a[i] - 1], prefix_sum[a[i]])
-            count[a[i]] = 0
-            i += 1
+        temp = 0
+        while j <= max_a:
+            temp += count[j]
+            j += i
+        max_group_size = max(max_group_size, temp)
     return max_group_size
 
 if __name__ == "__main__":

2023-11-04 17:24:32.474 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:24:32.474 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:24:32.474 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:24:32.474 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

2023-11-04 17:24:32.474 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
3
2
6
---
3
3
2
7
2023-11-04 17:24:32.474 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-04 17:24:32.474 | INFO     | alpha_codium.gen.coding_competitor:run:127 - counter: 4
2023-11-04 17:24:32.480 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:24:32.480 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:24:32.480 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:24:32.480 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self-reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'

A solution code that was generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, max_a + 1):
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

expected output:
3
3
2
6
code output:
3
3
2
7
====================
====================
'


Your goal is to analyze the code and the error, find the problem in the code, and propose a fix so the code will pass the input example.
Offer a fix that will keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-04 17:24:47.073 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "8\n465 55 3 54 234 12 45 78\n",
      "expected_output": "6\n",
      "code_output": "7\n"
    }
  ]
what_went_wrong: |-
  The problem with the code is in the way it calculates the size of the friend groups. The code is trying to find the maximum size of the friend group by checking the count of numbers that are multiples of each number in the array. However, this approach is incorrect because it does not consider the fact that the numbers in the friend group should have the same remainder when divided by a certain number m. Therefore, the code might overestimate the size of the friend group, as it happened in the failed test case.
  To fix this issue, we need to change the way we calculate the size of the friend groups. Instead of counting the multiples of each number, we should count the numbers that have the same remainder when divided by each number in the array. This can be achieved by using a dictionary to store the remainders and their counts, and then finding the maximum count.
input_output_fixed_flow: |-
  - Read the input and sort the array.
  - Initialize a dictionary to store the remainders and their counts.
  - For each number in the array, calculate the remainder when it is divided by each number in the array, and update the count in the dictionary.
  - Find the maximum count in the dictionary, which represents the size of the largest friend group.
  - Repeat the process for each test case and print the results.
2023-11-04 17:24:47.074 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:24:47.074 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:24:47.084 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:24:47.084 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:24:47.084 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:24:47.084 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, max_a + 1):
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the input-output example test, the code failed to produce the expected output.
Using the provided analysis, you need generate a fixed solution code, that will pass all the tests.

Error message when running the 'solution code':
'
test input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

expected output:
3
3
2
6
code output:
3
3
2
7
====================
====================
'

what_went_wrong:
'
The problem with the code is in the way it calculates the size of the friend groups. The code is trying to find the maximum size of the friend group by checking the count of numbers that are multiples of each number in the array. However, this approach is incorrect because it does not consider the fact that the numbers in the friend group should have the same remainder when divided by a certain number m. Therefore, the code might overestimate the size of the friend group, as it happened in the failed test case.
To fix this issue, we need to change the way we calculate the size of the friend groups. Instead of counting the multiples of each number, we should count the numbers that have the same remainder when divided by each number in the array. This can be achieved by using a dictionary to store the remainders and their counts, and then finding the maximum count.
'

input_output_fixed_flow:
'
- Read the input and sort the array.
- Initialize a dictionary to store the remainders and their counts.
- For each number in the array, calculate the remainder when it is divided by each number in the array, and update the count in the dictionary.
- Find the maximum count in the dictionary, which represents the size of the largest friend group.
- Repeat the process for each test case and print the results.
'

guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-04 17:24:54.722 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, max_a + 1):
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
2023-11-04 17:24:54.722 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:24:54.722 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:24:54.723 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:

2023-11-04 17:24:54.729 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:24:54.729 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:24:54.729 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:24:54.729 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

2023-11-04 17:24:54.730 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
3
2
6
---
3
3
2
7
2023-11-04 17:24:54.730 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-04 17:24:54.730 | ERROR    | alpha_codium.gen.coding_competitor:run:120 - error string did not change.
2023-11-04 17:24:54.730 | INFO     | alpha_codium.gen.coding_competitor:run:127 - counter: 5
2023-11-04 17:24:54.730 | ERROR    | alpha_codium.gen.coding_competitor:run:136 - Failed to pass public tests after 4 attempts
2023-11-04 17:24:54.731 | INFO     | alpha_codium.gen.coding_competitor:run:157 - =====================================
2023-11-04 17:24:54.731 | INFO     | alpha_codium.gen.coding_competitor:run:158 - passed public tests status: False
2023-11-04 17:24:54.731 | INFO     | alpha_codium.gen.coding_competitor:run:159 - =====================================
2023-11-04 17:24:54.731 | ERROR    | alpha_codium.gen.coding_competitor:run:164 - Failed to save recording
2023-11-04 17:24:54.735 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:24:54.735 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:24:54.735 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:24:54.736 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

2023-11-04 17:24:54.736 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
3
2
6
---
3
3
2
7
2023-11-04 17:24:54.736 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-04 17:24:54.736 | ERROR    | alpha_codium.gen.coding_competitor:run:185 - Failed to pass ai tests. trying to fix code
2023-11-04 17:24:54.742 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:24:54.742 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:24:54.743 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:24:54.743 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self-reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'

A solution code that was generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, max_a + 1):
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

expected output:
3
3
2
6
code output:
3
3
2
7
====================
====================
'


Your goal is to analyze the code and the error, find the problem in the code, and propose a fix so the code will pass the input example.
Offer a fix that will keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-04 17:25:05.949 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "4\n5\n1 5 2 4 6\n4\n8 2 5 10\n2\n1000 2000\n8\n465 55 3 54 234 12 45 78\n",
      "expected_output": "3\n3\n2\n6\n",
      "code_output": "3\n3\n2\n7\n"
    }
  ]
what_went_wrong: |-
  The issue with the code is that it is checking for all possible values of m up to the maximum value in the array. However, the problem statement does not require us to find the exact value of m. We only need to find the largest group of integers that share the same remainder when divided by a certain integer m. Therefore, checking for all possible values of m is unnecessary and can lead to incorrect results. The code should instead focus on finding the largest group of integers that share the same remainder.
input_output_fixed_flow: |-
  - Read the number of test cases and the test cases themselves.
  - For each test case, sort the array and create a count array to keep track of the frequency of each number.
  - Initialize the maximum group size to the maximum frequency in the count array.
  - Iterate over the array and for each number, find the frequency of numbers that are multiples of it (since they will have the same remainder when divided by it).
  - Update the maximum group size if the frequency of multiples is greater.
  - Print the maximum group size for each test case.
2023-11-04 17:25:05.950 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:25:05.950 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:25:05.959 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-04 17:25:05.959 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-04 17:25:05.959 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-04 17:25:05.959 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

problem description:
'
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that "every positive integer was one of his personal friends."

It turns out that positive integers can also be friends with each other! You are given an array a of distinct positive integers. 

Define a subarray a_i, a_{i+1}, …, a_j to be a friend group if and only if there exists an integer m ≥ 2 such that a_i mod m = a_{i+1} mod m = … = a_j mod m, where x mod y denotes the remainder when x is divided by y.

Your friend Gregor wants to know the size of the largest friend group in a.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 2⋅ 10^4). 

Each test case begins with a line containing the integer n (1 ≤ n ≤ 2 ⋅ 10^5), the size of the array a.

The next line contains n positive integers a_1, a_2, …, a_n (1 ≤ a_i ≤ {10}^{18}), representing the contents of the array a. It is guaranteed that all the numbers in a are distinct.

It is guaranteed that the sum of n over all test cases is less than 2⋅ 10^5.

Output

Your output should consist of t lines. Each line should consist of a single integer, the size of the largest friend group in a.

Example

Input


4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78


Output


3
3
2
6

Note

In the first test case, the array is [1,5,2,4,6]. The largest friend group is [2,4,6], since all those numbers are congruent to 0 modulo 2, so m=2.

In the second test case, the array is [8,2,5,10]. The largest friend group is [8,2,5], since all those numbers are congruent to 2 modulo 3, so m=3.

In the third case, the largest friend group is [1000,2000]. There are clearly many possible values of m that work.
'

self reflection on the problem:
'
- The problem is about finding the largest group of integers in an array that share the same remainder when divided by a certain integer m (m ≥ 2).
- The input consists of multiple test cases. Each test case starts with an integer n, the size of the array, followed by n distinct positive integers.
- The output should be the size of the largest group of integers that share the same remainder for each test case.
- The constraints are that the number of test cases t is between 1 and 2*10^4, the size of the array n is between 1 and 2*10^5, and the integers in the array are between 1 and 10^18.
'


A solution code generated for the problem:
'
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, max_a + 1):
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
'


However, when running the input-output example test, the code failed to produce the expected output.
Using the provided analysis, you need generate a fixed solution code, that will pass all the tests.

Error message when running the 'solution code':
'
test input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

expected output:
3
3
2
6
code output:
3
3
2
7
====================
====================
'

what_went_wrong:
'
The issue with the code is that it is checking for all possible values of m up to the maximum value in the array. However, the problem statement does not require us to find the exact value of m. We only need to find the largest group of integers that share the same remainder when divided by a certain integer m. Therefore, checking for all possible values of m is unnecessary and can lead to incorrect results. The code should instead focus on finding the largest group of integers that share the same remainder.
'

input_output_fixed_flow:
'
- Read the number of test cases and the test cases themselves.
- For each test case, sort the array and create a count array to keep track of the frequency of each number.
- Initialize the maximum group size to the maximum frequency in the count array.
- Iterate over the array and for each number, find the frequency of numbers that are multiples of it (since they will have the same remainder when divided by it).
- Update the maximum group size if the frequency of multiples is greater.
- Print the maximum group size for each test case.
'

guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-04 17:25:15.660 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, int(max_a ** 0.5) + 1): # only need to check up to sqrt(max_a)
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))
2023-11-04 17:25:15.662 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-04 17:25:15.662 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-04 17:25:15.663 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -17,7 +17,7 @@
     for i in a:
         count[i] += 1
     max_group_size = max(count)
-    for i in range(2, max_a + 1):
+    for i in range(2, int(max_a ** 0.5) + 1): # only need to check up to sqrt(max_a)
         j = i
         temp = 0
         while j <= max_a:

2023-11-04 17:25:15.667 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:25:15.667 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:25:15.667 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:25:15.667 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
5
1 5 2 4 6
4
8 2 5 10
2
1000 2000
8
465 55 3 54 234 12 45 78

2023-11-04 17:25:15.667 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
3
2
6
---
3
3
2
7
2023-11-04 17:25:15.667 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-04 17:25:15.668 | ERROR    | alpha_codium.gen.coding_competitor:run:196 - Failed to pass ai tests after trying to fix code. reverting to last solution
2023-11-04 17:25:15.669 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:25:15.670 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:25:15.670 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:25:15.670 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
3
3 6 9

2023-11-04 17:25:15.670 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
---
3
2023-11-04 17:25:15.670 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-04 17:25:15.672 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:25:15.672 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:25:15.672 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:25:15.672 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
5
5 10 15 20 25

2023-11-04 17:25:15.672 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
5
---
5
2023-11-04 17:25:15.673 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-04 17:25:15.674 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:25:15.674 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:25:15.674 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:25:15.674 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
2
4
4 8 12 16
5
5 10 15 20 25

2023-11-04 17:25:15.675 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
4
5
---
4
5
2023-11-04 17:25:15.675 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-04 17:25:15.676 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:25:15.676 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:25:15.676 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:25:15.677 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
3
4
4 8 12 16
5
5 10 15 20 25
6
6 12 18 24 30 36

2023-11-04 17:25:15.677 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
4
5
6
---
4
5
6
2023-11-04 17:25:15.677 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-04 17:25:15.678 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-04 17:25:15.678 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-04 17:25:15.678 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-04 17:25:15.679 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
4
4 8 12 16
5
5 10 15 20 25
6
6 12 18 24 30 36
7
7 14 21 28 35 42 49

2023-11-04 17:25:15.679 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
4
5
6
7
---
4
5
6
7
2023-11-04 17:25:15.679 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-04 17:25:15.679 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:237 - testing solution on private tests with prediction:
import sys
from collections import defaultdict

def read_input():
    t = int(input().strip())
    test_cases = []
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        test_cases.append((n, a))
    return t, test_cases

def find_largest_friend_group(n, a):
    a.sort()
    max_a = a[-1]
    count = [0] * (max_a + 1)
    for i in a:
        count[i] += 1
    max_group_size = max(count)
    for i in range(2, max_a + 1):
        j = i
        temp = 0
        while j <= max_a:
            temp += count[j]
            j += i
        max_group_size = max(max_group_size, temp)
    return max_group_size

if __name__ == "__main__":
    t, test_cases = read_input()
    for n, a in test_cases:
        print(find_largest_friend_group(n, a))

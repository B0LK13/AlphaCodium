2023-11-03 21:01:16.333 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:192 - problem_name: 1575_L. Longest Array Deconstruction
2023-11-03 21:01:16.337 | INFO     | alpha_codium.gen.coding_competitor:run:66 - Running code contests competitor, model gpt-4
2023-11-03 21:01:16.338 | INFO     | alpha_codium.gen.stages.utils:set_configurations:16 - recording_path: ./code_contests/1575_L. Longest Array Deconstruction/gpt-4/
do_record: True
use_record: False
2023-11-03 21:01:16.338 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:13 - --reflection stage--
2023-11-03 21:01:16.341 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:01:16.341 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:01:16.341 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-03 21:01:16.341 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1575_L. Longest Array Deconstruction'


problem description:
'
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=3, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-03 21:01:56.230 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem involves a sequence of integers, indexed from 1 to n.
  - A function f(a) is defined, which counts the number of indices where the value of the element at that index equals the index itself.
  - The goal is to maximize the value of f(a) by removing zero or more elements from the sequence.
  - After removing an element, the remaining elements are concatenated together, effectively re-indexing the sequence.
  - The input consists of an integer n, representing the initial length of the sequence, and a sequence of n integers.
  - The output should be the maximum possible value of f(a) after performing the allowed operations.
possible_solutions:
- name: Brute Force
  content: |
    Iterate over the sequence and for each element, calculate the value of f(a) if that element is removed. Keep track of the maximum value of f(a) found. Repeat this process until no more elements can be removed that increase the value of f(a). This solution is not efficient and will not work for large inputs due to its high time complexity.
  labels:
  - Brute Force
  complexity: |
    The time complexity is O(n^2) because for each element, we are calculating f(a) for the remaining elements. The space complexity is O(n) for storing the sequence.

- name: Greedy Approach
  content: |
    Sort the sequence in descending order. Then, iterate over the sequence and remove the first element that does not satisfy a_i = i. Repeat this process until all remaining elements satisfy a_i = i. This solution is more efficient than the brute force approach, but it may not always find the optimal solution.
  labels:
  - Greedy
  complexity: |
    The time complexity is O(n log n) for sorting the sequence and O(n) for iterating over the sequence, so the total time complexity is O(n log n). The space complexity is O(n) for storing the sequence.

- name: Dynamic Programming
  content: |
    Use a dynamic programming approach where dp[i] represents the maximum value of f(a) for the subsequence ending at index i. For each index, calculate dp[i] as the maximum of dp[i-1] and dp[j] + 1 for all j < i where a_j < a_i. The maximum value in the dp array is the solution. This solution is efficient and always finds the optimal solution.
  labels:
  - Dynamic Programming
  complexity: |
    The time complexity is O(n^2) for the two nested loops and the space complexity is O(n) for the dp array.
2023-11-03 21:01:56.231 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:01:56.231 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:01:56.236 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:13 - --choose best solution stage--
2023-11-03 21:01:56.242 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:01:56.242 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:01:56.242 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-03 21:01:56.242 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem name: '1575_L. Longest Array Deconstruction'


problem description:
'
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
'


self reflection:
'
- The problem involves a sequence of integers, indexed from 1 to n.
- A function f(a) is defined, which counts the number of indices where the value of the element at that index equals the index itself.
- The goal is to maximize the value of f(a) by removing zero or more elements from the sequence.
- After removing an element, the remaining elements are concatenated together, effectively re-indexing the sequence.
- The input consists of an integer n, representing the initial length of the sequence, and a sequence of n integers.
- The output should be the maximum possible value of f(a) after performing the allowed operations.
'

possible solutions:
'
- name: Brute Force
  content: |
    Iterate over the sequence and for each element, calculate the value of f(a) if that element is removed. Keep track of the maximum value of f(a) found. Repeat this process until no more elements can be removed that increase the value of f(a). This solution is not efficient and will not work for large inputs due to its high time complexity.
  labels:
  - Brute Force
  complexity: |
    The time complexity is O(n^2) because for each element, we are calculating f(a) for the remaining elements. The space complexity is O(n) for storing the sequence.

- name: Greedy Approach
  content: |
    Sort the sequence in descending order. Then, iterate over the sequence and remove the first element that does not satisfy a_i = i. Repeat this process until all remaining elements satisfy a_i = i. This solution is more efficient than the brute force approach, but it may not always find the optimal solution.
  labels:
  - Greedy
  complexity: |
    The time complexity is O(n log n) for sorting the sequence and O(n) for iterating over the sequence, so the total time complexity is O(n log n). The space complexity is O(n) for storing the sequence.

- name: Dynamic Programming
  content: |
    Use a dynamic programming approach where dp[i] represents the maximum value of f(a) for the subsequence ending at index i. For each index, calculate dp[i] as the maximum of dp[i-1] and dp[j] + 1 for all j < i where a_j < a_i. The maximum value in the dp array is the solution. This solution is efficient and always finds the optimal solution.
  labels:
  - Dynamic Programming
  complexity: |
    The time complexity is O(n^2) for the two nested loops and the space complexity is O(n) for the dp array.
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way. Prefer dynamic programming if possible.
Be critical - the provided solutions may be wrong, or not fully solve the problem.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    input_output_examples_flow: str = Field(description="describe how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-03 21:02:25.230 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: Dynamic Programming
content: |
  Use a dynamic programming approach where dp[i] represents the maximum value of f(a) for the subsequence ending at index i. For each index, calculate dp[i] as the maximum of dp[i-1] and dp[j] + 1 for all j < i where a_j < a_i. The maximum value in the dp array is the solution. This solution is efficient and always finds the optimal solution.
labels:
  - Dynamic Programming
complexity: |
  The time complexity is O(n^2) for the two nested loops and the space complexity is O(n) for the dp array.
why: |
  The Dynamic Programming solution is the best because it always finds the optimal solution. It uses a bottom-up approach to build the solution, considering all possible subsequences and thus ensuring that the maximum possible value of f(a) is found. Although its time complexity is O(n^2), it is still reasonable for the given constraints of the problem (n ≤ 2 ⋅ 10^5).
flow: |
  - Initialize a dp array of size n with all elements set to 0.
  - Iterate over the sequence from left to right.
  - For each element at index i, iterate over all previous elements at index j.
  - If the value at index j is less than the value at index i, update dp[i] to the maximum of dp[i] and dp[j] + 1.
  - After iterating over the entire sequence, the maximum value in the dp array is the largest possible f(a).
input_output_examples_flow: |
  - For the first example, the sequence is [2,1,4,2,5,3,7]. The dp array after processing the entire sequence is [1,2,2,3,3,3,3]. The maximum value in the dp array is 3, which is the output.
  - For the second example, the sequence is [4,2,3,1]. The dp array after processing the entire sequence is [1,2,2,2]. The maximum value in the dp array is 2, which is the output.
2023-11-03 21:02:25.231 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:02:25.231 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:02:25.233 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-03 21:02:25.238 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:02:25.238 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:02:25.238 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:
You are an expert Python programmer.

You are given a code contest problem, self-reflection on the problem, and a description of the solution, in words.
Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- emphasis not accessing an index that is out of the range of a list

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

2023-11-03 21:02:25.238 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
problem description:
'
Mr. Chanek gives you a sequence a indexed from 1 to n. Define f(a) as the number of indices where a_i = i. 

You can pick an element from the current sequence and remove it, then concatenate the remaining elements together. For example, if you remove the 3-rd element from the sequence [4, 2, 3, 1], the resulting sequence will be [4, 2, 1]. 

You want to remove some elements from a in order to maximize f(a), using zero or more operations. Find the largest possible f(a).

Input

The first line contains one integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the initial length of the sequence.

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 2 ⋅ 10^5) — the initial sequence a.

Output

Output an integer denoting the largest f(a) that can be obtained by doing zero or more operations.

Examples

Input


7
2 1 4 2 5 3 7


Output


3


Input


4
4 2 3 1


Output


2

Note

In the first example, f(A) = 3 by doing the following operations.

[2,1,4,2,5,3,7] → [2,1,2,5,3,7] → [1,2,5,3,7] → [1,2,5,3] → [1,2,3]

In the second example, f(A) = 2 and no additional operation is needed.
'


self reflection:
'
- The problem involves a sequence of integers, indexed from 1 to n.
- A function f(a) is defined, which counts the number of indices where the value of the element at that index equals the index itself.
- The goal is to maximize the value of f(a) by removing zero or more elements from the sequence.
- After removing an element, the remaining elements are concatenated together, effectively re-indexing the sequence.
- The input consists of an integer n, representing the initial length of the sequence, and a sequence of n integers.
- The output should be the maximum possible value of f(a) after performing the allowed operations.

'

propose solution:
'
name: Dynamic Programming
content: |
  Use a dynamic programming approach where dp[i] represents the maximum value of f(a) for the subsequence ending at index i. For each index, calculate dp[i] as the maximum of dp[i-1] and dp[j] + 1 for all j < i where a_j < a_i. The maximum value in the dp array is the solution. This solution is efficient and always finds the optimal solution.
labels:
  - Dynamic Programming
complexity: |
  The time complexity is O(n^2) for the two nested loops and the space complexity is O(n) for the dp array.
why: |
  The Dynamic Programming solution is the best because it always finds the optimal solution. It uses a bottom-up approach to build the solution, considering all possible subsequences and thus ensuring that the maximum possible value of f(a) is found. Although its time complexity is O(n^2), it is still reasonable for the given constraints of the problem (n ≤ 2 ⋅ 10^5).
flow: |
  - Initialize a dp array of size n with all elements set to 0.
  - Iterate over the sequence from left to right.
  - For each element at index i, iterate over all previous elements at index j.
  - If the value at index j is less than the value at index i, update dp[i] to the maximum of dp[i] and dp[j] + 1.
  - After iterating over the entire sequence, the maximum value in the dp array is the largest possible f(a).
input_output_examples_flow: |
  - For the first example, the sequence is [2,1,4,2,5,3,7]. The dp array after processing the entire sequence is [1,2,2,3,3,3,3]. The maximum value in the dp array is 3, which is the output.
  - For the second example, the sequence is [4,2,3,1]. The dp array after processing the entire sequence is [1,2,2,2]. The maximum value in the dp array is 2, which is the output.
'

answer:
```python
2023-11-03 21:02:31.299 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def max_f(a, n):
    dp = [0] * (n + 1)
    for i in range(n):
        dp[a[i]] = max(dp[a[i]], dp[a[i] - 1] + 1)
    return max(dp)

if __name__ == "__main__":
    n = int(input().strip())
    a = list(map(int, input().strip().split()))
    print(max_f(a, n))
2023-11-03 21:02:31.300 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:02:31.300 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:02:31.301 | INFO     | alpha_codium.gen.coding_competitor:run:85 - --iterate on public tests stage--
2023-11-03 21:02:31.301 | INFO     | alpha_codium.gen.coding_competitor:run:98 - test_inputs:
7
2 1 4 2 5 3 7

2023-11-03 21:02:35.441 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:02:35.441 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-03 21:02:35.442 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-03 21:02:35.442 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
7
2 1 4 2 5 3 7

2023-11-03 21:02:35.442 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
3
---
3
2023-11-03 21:02:35.442 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:02:35.442 | INFO     | alpha_codium.gen.coding_competitor:run:121 - counter: 1
2023-11-03 21:02:35.442 | INFO     | alpha_codium.gen.coding_competitor:run:123 - Passed public tests after 1 attempts
2023-11-03 21:02:35.442 | INFO     | alpha_codium.gen.coding_competitor:run:98 - test_inputs:
4
4 2 3 1

2023-11-03 21:02:39.585 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:02:39.586 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-03 21:02:39.586 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-03 21:02:39.586 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
4
4 2 3 1

2023-11-03 21:02:39.586 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
---
2
2023-11-03 21:02:39.586 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:02:39.586 | INFO     | alpha_codium.gen.coding_competitor:run:121 - counter: 1
2023-11-03 21:02:39.586 | INFO     | alpha_codium.gen.coding_competitor:run:123 - Passed public tests after 1 attempts
2023-11-03 21:02:39.586 | INFO     | alpha_codium.gen.coding_competitor:run:151 - Passed public tests
2023-11-03 21:02:39.587 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:181 - testing solution on private tests with prediction:
def max_f(a, n):
    dp = [0] * (n + 1)
    for i in range(n):
        dp[a[i]] = max(dp[a[i]], dp[a[i] - 1] + 1)
    return max(dp)

if __name__ == "__main__":
    n = int(input().strip())
    a = list(map(int, input().strip().split()))
    print(max_f(a, n))
2023-11-03 21:02:43.686 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:02:43.686 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-03 21:02:43.686 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-03 21:02:43.686 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
1

2023-11-03 21:02:43.686 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
1
---
1
2023-11-03 21:02:43.686 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:02:43.686 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
200000

2023-11-03 21:02:43.687 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---

2023-11-03 21:02:43.687 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-1 :: status=ProgramStatus.kFailed, passed=False.  sandbox error:   File "<string>", line 14, in <module>
  File "<string>", line 13, in run_code_contests_solution
  File "<string>", line 7, in max_f
IndexError: list index out of range
2023-11-03 21:02:43.687 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:212 - =====================================
2023-11-03 21:02:43.687 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:213 - test_passed: 1, test_failed: 1
2023-11-03 21:02:43.687 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:214 - =====================================

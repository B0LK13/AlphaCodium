2023-11-03 21:29:04.901 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:192 - problem_name: 1575_G. GCD Festival
2023-11-03 21:29:04.984 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:195 - problem['cf_tags']: ['math', 'number theory']
2023-11-03 21:29:04.988 | INFO     | alpha_codium.gen.coding_competitor:run:66 - Running code contests competitor, model gpt-4
2023-11-03 21:29:04.988 | INFO     | alpha_codium.gen.stages.utils:set_configurations:16 - recording_path: ./code_contests/1575_G. GCD Festival/gpt-4/
do_record: True
use_record: False
2023-11-03 21:29:04.989 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:13 - --reflection stage--
2023-11-03 21:29:04.992 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:29:04.992 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:29:04.992 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-03 21:29:04.992 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1575_G. GCD Festival'


problem description:
'
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=3, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-03 21:29:31.269 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem is about calculating the prettiness value of an array of integers. 
  - The prettiness value is calculated by summing up the product of the greatest common divisor (GCD) of every pair of elements in the array and the GCD of their respective indices.
  - The input consists of an integer n representing the size of the array and n integers representing the elements of the array.
  - The output should be the prettiness value modulo 10^9 + 7.
  - The constraints are that n can be between 2 and 10^5 and each element of the array can be between 1 and 10^5.

possible_solutions:
- name: Brute Force
  content: |
    A brute force solution would involve calculating the GCD of every pair of elements in the array and their indices, then summing up the products. However, this approach would have a time complexity of O(n^2), which is not feasible for large inputs.
  labels:
  - Brute Force
  complexity: |
    Time complexity is O(n^2), which is not feasible for large inputs.

- name: Precompute GCDs
  content: |
    A more efficient solution would involve precomputing the GCDs of all pairs of numbers up to 10^5. This can be done using a 2D array where the value at index [i][j] is the GCD of i and j. Then, for each pair of elements in the array, we can look up their GCD and the GCD of their indices in constant time. The total time complexity would be O(n).
  labels:
  - Precomputation
  complexity: |
    Time complexity is O(n), which is feasible for large inputs.

- name: Sieve of Eratosthenes
  content: |
    Another approach would be to use the Sieve of Eratosthenes to generate all primes up to 10^5, then use these primes to calculate the GCDs. This would reduce the time complexity of calculating the GCDs, but would increase the space complexity due to the need to store the primes.
  labels:
  - Sieve of Eratosthenes
  complexity: |
    Time complexity is O(n log log n) for generating the primes and O(n) for calculating the prettiness value, for a total time complexity of O(n log log n). Space complexity is O(n) for storing the primes.
2023-11-03 21:29:31.270 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:29:31.270 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:29:31.274 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:13 - --choose best solution stage--
2023-11-03 21:29:31.281 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:29:31.281 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:29:31.281 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-03 21:29:31.281 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem name: '1575_G. GCD Festival'


problem description:
'
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
'


self reflection:
'
- The problem is about calculating the prettiness value of an array of integers. 
- The prettiness value is calculated by summing up the product of the greatest common divisor (GCD) of every pair of elements in the array and the GCD of their respective indices.
- The input consists of an integer n representing the size of the array and n integers representing the elements of the array.
- The output should be the prettiness value modulo 10^9 + 7.
- The constraints are that n can be between 2 and 10^5 and each element of the array can be between 1 and 10^5.
'

possible solutions:
'
- name: Brute Force
  content: |
    A brute force solution would involve calculating the GCD of every pair of elements in the array and their indices, then summing up the products. However, this approach would have a time complexity of O(n^2), which is not feasible for large inputs.
  labels:
  - Brute Force
  complexity: |
    Time complexity is O(n^2), which is not feasible for large inputs.

- name: Precompute GCDs
  content: |
    A more efficient solution would involve precomputing the GCDs of all pairs of numbers up to 10^5. This can be done using a 2D array where the value at index [i][j] is the GCD of i and j. Then, for each pair of elements in the array, we can look up their GCD and the GCD of their indices in constant time. The total time complexity would be O(n).
  labels:
  - Precomputation
  complexity: |
    Time complexity is O(n), which is feasible for large inputs.

- name: Sieve of Eratosthenes
  content: |
    Another approach would be to use the Sieve of Eratosthenes to generate all primes up to 10^5, then use these primes to calculate the GCDs. This would reduce the time complexity of calculating the GCDs, but would increase the space complexity due to the need to store the primes.
  labels:
  - Sieve of Eratosthenes
  complexity: |
    Time complexity is O(n log log n) for generating the primes and O(n) for calculating the prettiness value, for a total time complexity of O(n log log n). Space complexity is O(n) for storing the primes.
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way. Prefer dynamic programming if possible.
Be critical - the provided solutions may be wrong, or not fully solve the problem.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): brute force, binary search, dynamic programming, trees, greedy, combinatorics, dfs, bfs, graphs, constructive algorithms, math, data structures, geometry, number theory, ...")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    input_output_examples_flow: str = Field(description="describe how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-03 21:29:51.735 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: Precompute GCDs
content: |
  A more efficient solution would involve precomputing the GCDs of all pairs of numbers up to 10^5. This can be done using a 2D array where the value at index [i][j] is the GCD of i and j. Then, for each pair of elements in the array, we can look up their GCD and the GCD of their indices in constant time. The total time complexity would be O(n).
labels:
  - Precomputation
complexity: |
  Time complexity is O(n), which is feasible for large inputs.
why: |
  This solution is the best because it reduces the time complexity from O(n^2) to O(n) by precomputing the GCDs. This makes it feasible to handle large inputs within the given constraints. It also fully solves the problem as it calculates the prettiness value as required.
flow: |
  - Precompute the GCDs of all pairs of numbers up to 10^5 and store them in a 2D array.
  - Read the input array.
  - Initialize a variable to store the total prettiness value.
  - For each pair of elements in the array, look up their GCD and the GCD of their indices in the precomputed array.
  - Multiply the two GCDs and add the result to the total prettiness value.
  - After going through all pairs, output the total prettiness value modulo 10^9 + 7.
input_output_examples_flow: |
  - For the input example, the array is [3, 6, 2, 1, 4].
  - The GCDs of all pairs of numbers up to 10^5 have been precomputed.
  - For each pair of elements, we look up their GCD and the GCD of their indices in the precomputed array.
  - For example, for the pair (3, 6), the GCD is 3 and the GCD of their indices (1, 2) is 1. So, the contribution to the total prettiness value is 3 * 1 = 3.
  - We do this for all pairs and add up the results to get the total prettiness value.
  - Finally, we output the total prettiness value modulo 10^9 + 7, which is 77.
2023-11-03 21:29:51.736 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:29:51.737 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:29:51.744 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-03 21:29:51.752 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:29:51.753 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:29:51.753 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:
You are an expert Python programmer.

You are given a code contest problem, self-reflection on the problem, and a description of the solution, in words.
Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- emphasis not accessing an index that is out of the range of a list

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

2023-11-03 21:29:51.753 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
problem description:
'
Mr. Chanek has an array a of n integers. The prettiness value of a is denoted as:

$$$∑_{i=1}^{n} {∑_{j=1}^{n} {\gcd(a_i, a_j) ⋅ \gcd(i, j)}}$$$

where \gcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.

In other words, the prettiness value of an array a is the total sum of \gcd(a_i, a_j) ⋅ \gcd(i, j) for all pairs (i, j).

Help Mr. Chanek find the prettiness value of a, and output the result modulo 10^9 + 7!

Input

The first line contains an integer n (2 ≤ n ≤ 10^5).

The second line contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^5).

Output

Output an integer denoting the prettiness value of a modulo 10^9 + 7.

Example

Input


5
3 6 2 1 4


Output


77
'


self reflection:
'
- The problem is about calculating the prettiness value of an array of integers. 
- The prettiness value is calculated by summing up the product of the greatest common divisor (GCD) of every pair of elements in the array and the GCD of their respective indices.
- The input consists of an integer n representing the size of the array and n integers representing the elements of the array.
- The output should be the prettiness value modulo 10^9 + 7.
- The constraints are that n can be between 2 and 10^5 and each element of the array can be between 1 and 10^5.

'

propose solution:
'
name: Precompute GCDs
content: |
  A more efficient solution would involve precomputing the GCDs of all pairs of numbers up to 10^5. This can be done using a 2D array where the value at index [i][j] is the GCD of i and j. Then, for each pair of elements in the array, we can look up their GCD and the GCD of their indices in constant time. The total time complexity would be O(n).
labels:
  - Precomputation
complexity: |
  Time complexity is O(n), which is feasible for large inputs.
why: |
  This solution is the best because it reduces the time complexity from O(n^2) to O(n) by precomputing the GCDs. This makes it feasible to handle large inputs within the given constraints. It also fully solves the problem as it calculates the prettiness value as required.
flow: |
  - Precompute the GCDs of all pairs of numbers up to 10^5 and store them in a 2D array.
  - Read the input array.
  - Initialize a variable to store the total prettiness value.
  - For each pair of elements in the array, look up their GCD and the GCD of their indices in the precomputed array.
  - Multiply the two GCDs and add the result to the total prettiness value.
  - After going through all pairs, output the total prettiness value modulo 10^9 + 7.
input_output_examples_flow: |
  - For the input example, the array is [3, 6, 2, 1, 4].
  - The GCDs of all pairs of numbers up to 10^5 have been precomputed.
  - For each pair of elements, we look up their GCD and the GCD of their indices in the precomputed array.
  - For example, for the pair (3, 6), the GCD is 3 and the GCD of their indices (1, 2) is 1. So, the contribution to the total prettiness value is 3 * 1 = 3.
  - We do this for all pairs and add up the results to get the total prettiness value.
  - Finally, we output the total prettiness value modulo 10^9 + 7, which is 77.
'

answer:
```python
2023-11-03 21:30:03.123 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
import math

MOD = 10**9 + 7

def gcd(x, y):
    while(y):
        x, y = y, x % y
    return x

def precompute_gcds(n):
    gcds = [[0 for _ in range(n+1)] for _ in range(n+1)]
    for i in range(1, n+1):
        for j in range(i, n+1):
            gcds[i][j] = gcds[j][i] = gcd(i, j)
    return gcds

def calculate_prettiness(n, a, gcds):
    prettiness = 0
    for i in range(n):
        for j in range(n):
            prettiness += gcds[a[i]][a[j]] * gcds[i+1][j+1]
            prettiness %= MOD
    return prettiness

if __name__ == "__main__":
    n = int(input().strip())
    a = list(map(int, input().strip().split()))
    gcds = precompute_gcds(max(max(a), n))
    prettiness = calculate_prettiness(n, a, gcds)
    print(prettiness)
2023-11-03 21:30:03.124 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:30:03.124 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:30:03.126 | INFO     | alpha_codium.gen.coding_competitor:run:85 - --iterate on public tests stage--
2023-11-03 21:30:03.126 | INFO     | alpha_codium.gen.coding_competitor:run:98 - test_inputs:
5
3 6 2 1 4

2023-11-03 21:30:07.389 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:30:07.391 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-03 21:30:07.391 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-03 21:30:07.391 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5
3 6 2 1 4

2023-11-03 21:30:07.391 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
77
---
77
2023-11-03 21:30:07.391 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:30:07.392 | DEBUG    | alpha_codium.gen.coding_competitor:clip_string:160 - clipping string from 691 to 50
2023-11-03 21:30:07.392 | INFO     | alpha_codium.gen.coding_competitor:run:121 - counter: 1
2023-11-03 21:30:07.392 | INFO     | alpha_codium.gen.coding_competitor:run:123 - Passed public tests after 1 attempts
2023-11-03 21:30:07.392 | INFO     | alpha_codium.gen.coding_competitor:run:151 - Passed public tests
2023-11-03 21:30:07.393 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:181 - testing solution on private tests with prediction:
import math

MOD = 10**9 + 7

def gcd(x, y):
    while(y):
        x, y = y, x % y
    return x

def precompute_gcds(n):
    gcds = [[0 for _ in range(n+1)] for _ in range(n+1)]
    for i in range(1, n+1):
        for j in range(i, n+1):
            gcds[i][j] = gcds[j][i] = gcd(i, j)
    return gcds

def calculate_prettiness(n, a, gcds):
    prettiness = 0
    for i in range(n):
        for j in range(n):
            prettiness += gcds[a[i]][a[j]] * gcds[i+1][j+1]
            prettiness %= MOD
    return prettiness

if __name__ == "__main__":
    n = int(input().strip())
    a = list(map(int, input().strip().split()))
    gcds = precompute_gcds(max(max(a), n))
    prettiness = calculate_prettiness(n, a, gcds)
    print(prettiness)
2023-11-03 21:30:20.566 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kTimeout
2023-11-03 21:30:20.567 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-03 21:30:20.567 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-03 21:30:20.567 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:213 - =====================================
2023-11-03 21:30:20.567 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:214 - test_passed: 0, test_failed: 0
2023-11-03 21:30:20.567 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:215 - =====================================

2023-11-06 13:53:17.473 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:137 - problem_name: 1579_E2. Array Optimization by Deque
2023-11-06 13:53:17.476 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:140 - problem['cf_tags']: ['data structures', 'greedy']
2023-11-06 13:53:17.478 | INFO     | alpha_codium.gen.coding_competitor:run:71 - Running code contests competitor, model gpt-4
2023-11-06 13:53:17.479 | INFO     | alpha_codium.gen.stages.utils:set_configurations:17 - recording_path: /Users/talrid/Git/alphaCodium/alpha_codium/gen/code_contests/1579_E2. Array Optimization by Deque/gpt-4/
do_record: True
use_record: False
2023-11-06 13:53:17.479 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:15 - --reflection stage--
2023-11-06 13:53:17.482 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:53:17.482 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:53:17.482 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:53:17.482 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1579_E2. Array Optimization by Deque'


problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=3, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-06 13:53:41.964 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem is about optimizing an array using a deque (double-ended queue) data structure.
  - We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
  - The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
  - An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
  - The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
  - The output should be the minimum possible number of inversions for each test case.
possible_solutions:
- name: Brute Force
  content: |
    - For each test case, generate all possible sequences by adding each element of the array to either the beginning or the end of the deque.
    - For each sequence, calculate the number of inversions.
    - Return the minimum number of inversions among all sequences.
  labels:
  - Brute Force
  complexity: |
    - Time complexity is O(n!) because we need to generate all possible sequences.
    - Space complexity is O(n) because we need to store the sequence in the deque.

- name: Greedy Approach
  content: |
    - For each test case, start by adding the first element of the array to the deque.
    - For each subsequent element, if it is less than or equal to the first element of the deque, add it to the beginning. Otherwise, add it to the end.
    - Calculate the number of inversions in the final sequence.
  labels:
  - Greedy
  complexity: |
    - Time complexity is O(n) because we need to process each element of the array once.
    - Space complexity is O(n) because we need to store the sequence in the deque.

- name: Dynamic Programming
  content: |
    - For each test case, create a 2D DP table where DP[i][j] represents the minimum number of inversions when the first i elements of the array are processed and the jth element is at the beginning of the deque.
    - Initialize the DP table with infinity and update the values based on the greedy approach.
    - The minimum number of inversions for the test case is the minimum value in the last row of the DP table.
  labels:
  - Dynamic Programming
  complexity: |
    - Time complexity is O(n^2) because we need to fill up the DP table.
    - Space complexity is O(n^2) because we need to store the DP table.
2023-11-06 13:53:41.964 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:53:41.965 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:53:41.971 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:43 - Enforcing dynamic programming solution: Dynamic Programming
2023-11-06 13:53:41.972 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:13 - --choose best solution stage--
2023-11-06 13:53:41.978 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:53:41.978 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:53:41.978 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:53:41.978 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

possible solutions:
'
{'name': 'Dynamic Programming', 'content': '- For each test case, create a 2D DP table where DP[i][j] represents the minimum number of inversions when the first i elements of the array are processed and the jth element is at the beginning of the deque.\n- Initialize the DP table with infinity and update the values based on the greedy approach.\n- The minimum number of inversions for the test case is the minimum value in the last row of the DP table.\n', 'labels': ['Dynamic Programming'], 'complexity': '- Time complexity is O(n^2) because we need to fill up the DP table.\n- Space complexity is O(n^2) because we need to store the DP table.'}
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way.
Be critical - the provided solutions might be wrong, or not fully solve the problem.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): brute force, binary search, dynamic programming, trees, greedy, combinatorics, dfs, bfs, graphs, constructive algorithms, math, data structures, geometry, number theory, ...")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    input_output_examples_flow: str = Field(description="describe in details how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-06 13:54:09.779 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: Dynamic Programming
content: |
  - For each test case, create a 2D DP table where DP[i][j] represents the minimum number of inversions when the first i elements of the array are processed and the jth element is at the beginning of the deque.
  - Initialize the DP table with infinity and update the values based on the greedy approach.
  - The minimum number of inversions for the test case is the minimum value in the last row of the DP table.
labels:
  - Dynamic Programming
complexity: |
  - Time complexity is O(n^2) because we need to fill up the DP table.
  - Space complexity is O(n^2) because we need to store the DP table.
why: |
  The problem is about minimizing the number of inversions in a deque after processing an array of integers. The dynamic programming approach is suitable for this problem because it involves making an optimal choice at each step (adding an element to the beginning or the end of the deque) while keeping track of the minimum number of inversions. The solution is robust as it considers all possible choices at each step and ensures the minimum number of inversions.
flow: |
  - Initialize a 2D DP table with size n x n, where n is the size of the array.
  - For each element in the array, calculate the number of inversions if it is added to the beginning or the end of the deque.
  - Update the DP table with the minimum number of inversions.
  - After processing all elements, the minimum number of inversions for the test case is the minimum value in the last row of the DP table.
input_output_examples_flow: |
  - For the first example, the array is [3, 7, 5, 5]. The DP table is initialized with infinity.
  - The first element 3 is processed. It can be added to the beginning or the end of the deque without causing any inversion. The DP table is updated.
  - The second element 7 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - The third element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it causes one inversion with 7. The DP table is updated.
  - The fourth element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - After processing all elements, the minimum number of inversions is 2, which is the minimum value in the last row of the DP table.
2023-11-06 13:54:09.779 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:54:09.780 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:54:09.785 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-06 13:54:09.791 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:54:09.791 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:54:09.791 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:54:09.791 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a proposed solution:

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.

'

proposed solution:
'
name: Dynamic Programming
content: |
  - For each test case, create a 2D DP table where DP[i][j] represents the minimum number of inversions when the first i elements of the array are processed and the jth element is at the beginning of the deque.
  - Initialize the DP table with infinity and update the values based on the greedy approach.
  - The minimum number of inversions for the test case is the minimum value in the last row of the DP table.
labels:
  - Dynamic Programming
complexity: |
  - Time complexity is O(n^2) because we need to fill up the DP table.
  - Space complexity is O(n^2) because we need to store the DP table.
why: |
  The problem is about minimizing the number of inversions in a deque after processing an array of integers. The dynamic programming approach is suitable for this problem because it involves making an optimal choice at each step (adding an element to the beginning or the end of the deque) while keeping track of the minimum number of inversions. The solution is robust as it considers all possible choices at each step and ensures the minimum number of inversions.
flow: |
  - Initialize a 2D DP table with size n x n, where n is the size of the array.
  - For each element in the array, calculate the number of inversions if it is added to the beginning or the end of the deque.
  - Update the DP table with the minimum number of inversions.
  - After processing all elements, the minimum number of inversions for the test case is the minimum value in the last row of the DP table.
input_output_examples_flow: |
  - For the first example, the array is [3, 7, 5, 5]. The DP table is initialized with infinity.
  - The first element 3 is processed. It can be added to the beginning or the end of the deque without causing any inversion. The DP table is updated.
  - The second element 7 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - The third element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it causes one inversion with 7. The DP table is updated.
  - The fourth element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - After processing all elements, the minimum number of inversions is 2, which is the minimum value in the last row of the DP table.
'


Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and simulate running it on the provided input-output examples. Follow the 'input_output_examples_flow' section.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- Make sure to follow the 'flow' and 'input_output_examples_flow' sections.

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

answer:
```python
2023-11-06 13:54:20.940 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        if a[i-1] == a[i]:
            b[i] += 1
        else:
            c[i] += 1
    dp = [[0]*(n+1) for _ in range(n+1)]
    for i in range(n+1):
        dp[i][0] = dp[0][i] = i*(i-1)//2
    for l in range(2, n+1):
        i = a.index(l)
        j = a[::-1].index(l)
        for x in range(i+1):
            for y in range(l-i, l+1):
                dp[x][y] = min(dp[x][y], dp[x-1][y-1] + b[l-1] - b[i] + c[j] - c[l-y])
                if y != l:
                    dp[x][y] = min(dp[x][y], dp[x][y+1])
    return min(dp[i][n-i] for i in range(n+1))

if __name__ == "__main__":
    t = int(input().strip())
    for _ in range(t):
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        print(min_inversions(n, a))
2023-11-06 13:54:20.940 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:54:20.940 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:54:20.942 | INFO     | alpha_codium.gen.stages.run_generate_ai_test:run_generate_ai_tests:13 - --generate ai tests stage--
2023-11-06 13:54:20.948 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:54:20.949 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:54:20.949 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:54:20.949 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a possible solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

possible solution:
'
name: Dynamic Programming
content: |
  - For each test case, create a 2D DP table where DP[i][j] represents the minimum number of inversions when the first i elements of the array are processed and the jth element is at the beginning of the deque.
  - Initialize the DP table with infinity and update the values based on the greedy approach.
  - The minimum number of inversions for the test case is the minimum value in the last row of the DP table.
labels:
  - Dynamic Programming
complexity: |
  - Time complexity is O(n^2) because we need to fill up the DP table.
  - Space complexity is O(n^2) because we need to store the DP table.
why: |
  The problem is about minimizing the number of inversions in a deque after processing an array of integers. The dynamic programming approach is suitable for this problem because it involves making an optimal choice at each step (adding an element to the beginning or the end of the deque) while keeping track of the minimum number of inversions. The solution is robust as it considers all possible choices at each step and ensures the minimum number of inversions.
flow: |
  - Initialize a 2D DP table with size n x n, where n is the size of the array.
  - For each element in the array, calculate the number of inversions if it is added to the beginning or the end of the deque.
  - Update the DP table with the minimum number of inversions.
  - After processing all elements, the minimum number of inversions for the test case is the minimum value in the last row of the DP table.
input_output_examples_flow: |
  - For the first example, the array is [3, 7, 5, 5]. The DP table is initialized with infinity.
  - The first element 3 is processed. It can be added to the beginning or the end of the deque without causing any inversion. The DP table is updated.
  - The second element 7 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - The third element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it causes one inversion with 7. The DP table is updated.
  - The fourth element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - After processing all elements, the minimum number of inversions is 2, which is the minimum value in the last row of the DP table.
'

Your task is to generate 6 additional input-output examples for the problem.
They should be sorted by difficulty, from easiest to hardest.
It is essential that all the inputs are valid, and the outputs are correct. Double check them, and validate they match the problem description and constraints.
If relevant, the easiest test should be taken from one of the problem input examples.



The output must be a YAML object equivalent to type $ProblemTests, according to the following Pydantic definitions:
'
class Test(BaseModel):
    input: str
    output: str

class ProblemTests(BaseModel):
    tests: List[Test] = Field(min_items=6, max_items=6)
'


Example YAML output:
```yaml
tests:
- input: |
    ...
  output: |
    ...
...
```

Answer:
```yaml
2023-11-06 13:54:31.391 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
tests:
- input: |
    1
    1
    1
  output: |
    0
- input: |
    1
    2
    1 2
  output: |
    0
- input: |
    1
    3
    1 2 3
  output: |
    0
- input: |
    1
    4
    1 2 3 4
  output: |
    0
- input: |
    1
    5
    5 4 3 2 1
  output: |
    0
- input: |
    1
    6
    6 5 4 3 2 1
  output: |
    0
2023-11-06 13:54:31.391 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:54:31.392 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:54:31.393 | INFO     | alpha_codium.gen.stages.run_evaluate_a_simple_test:run_evaluate_a_simple_test:20 - --run simple test stage--
2023-11-06 13:54:31.405 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:54:31.405 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:54:31.405 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:54:31.405 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
1
1

2023-11-06 13:54:31.405 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---

2023-11-06 13:54:31.405 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kFailed, passed=False.  sandbox error:   File "<string>", line 29, in <module>
  File "<string>", line 7, in min_inversions
IndexError: list index out of range
2023-11-06 13:54:31.405 | ERROR    | alpha_codium.gen.stages.run_tests:run_tests:31 - failed to run solution
2023-11-06 13:54:31.405 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-06 13:54:31.408 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:54:31.408 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:54:31.408 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:54:31.409 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a proposed solution:

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.

'

proposed solution:
'
name: Dynamic Programming
content: |
  - For each test case, create a 2D DP table where DP[i][j] represents the minimum number of inversions when the first i elements of the array are processed and the jth element is at the beginning of the deque.
  - Initialize the DP table with infinity and update the values based on the greedy approach.
  - The minimum number of inversions for the test case is the minimum value in the last row of the DP table.
labels:
  - Dynamic Programming
complexity: |
  - Time complexity is O(n^2) because we need to fill up the DP table.
  - Space complexity is O(n^2) because we need to store the DP table.
why: |
  The problem is about minimizing the number of inversions in a deque after processing an array of integers. The dynamic programming approach is suitable for this problem because it involves making an optimal choice at each step (adding an element to the beginning or the end of the deque) while keeping track of the minimum number of inversions. The solution is robust as it considers all possible choices at each step and ensures the minimum number of inversions.
flow: |
  - Initialize a 2D DP table with size n x n, where n is the size of the array.
  - For each element in the array, calculate the number of inversions if it is added to the beginning or the end of the deque.
  - Update the DP table with the minimum number of inversions.
  - After processing all elements, the minimum number of inversions for the test case is the minimum value in the last row of the DP table.
input_output_examples_flow: |
  - For the first example, the array is [3, 7, 5, 5]. The DP table is initialized with infinity.
  - The first element 3 is processed. It can be added to the beginning or the end of the deque without causing any inversion. The DP table is updated.
  - The second element 7 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - The third element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it causes one inversion with 7. The DP table is updated.
  - The fourth element 5 is processed. It can be added to the beginning or the end of the deque. If it is added to the beginning, it causes one inversion with 3 and 7. If it is added to the end, it does not cause any inversion. The DP table is updated.
  - After processing all elements, the minimum number of inversions is 2, which is the minimum value in the last row of the DP table.
'


Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and simulate running it on the provided input-output examples. Follow the 'input_output_examples_flow' section.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- Make sure to follow the 'flow' and 'input_output_examples_flow' sections.

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

answer:
```python
2023-11-06 13:54:41.811 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:54:41.812 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:54:41.812 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:54:41.815 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:54:41.815 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:54:41.815 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:54:41.815 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
1
1

2023-11-06 13:54:41.816 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-06 13:54:41.816 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:54:41.817 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:19 - --iterate on public tests stage--
2023-11-06 13:54:41.819 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:54:41.819 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:54:41.819 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:54:41.820 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

2023-11-06 13:54:41.820 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
0
1
0
1
2
---
0
0
1
0
3
6
2023-11-06 13:54:41.820 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-06 13:54:41.820 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:58 - counter: 1
2023-11-06 13:54:41.827 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:54:41.827 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:54:41.827 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:54:41.828 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

A Python solution code that was generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
0
0
1
0
3
6
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific, and emphasize the fixes, and how do they apply to the input.")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-06 13:54:57.806 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "6\n4\n3 7 5 5\n3\n3 2 1\n3\n3 1 2\n4\n-1 2 2 -1\n4\n4 5 1 3\n5\n1 3 1 3 2\n",
      "expected_output": "2\n0\n1\n0\n1\n2\n",
      "code_output": "0\n0\n1\n0\n3\n6\n"
    }
  ]
what_went_wrong: |-
  The original code failed to correctly calculate the minimum number of inversions. The problem lies in the way the code is trying to calculate the inversions. It's trying to count the inversions by checking if the current element is greater than the previous one and then incrementing the count. However, this approach is incorrect because it doesn't consider the fact that elements can be added to either the beginning or the end of the deque, which can significantly affect the number of inversions. The code needs to be modified to correctly calculate the minimum number of inversions considering the flexibility of adding elements to either end of the deque.
failed_test_fixed_flow: |-
  - First, create a deque and two counters for the left and right inversions.
  - Iterate over the array from the second element to the last.
  - For each element, calculate the left and right inversions if the element is added to the beginning or the end of the deque respectively.
  - If the left inversions are less than or equal to the right inversions, add the element to the beginning of the deque and update the left inversions counter.
  - Otherwise, add the element to the end of the deque and update the right inversions counter.
  - After iterating over all elements, the sum of the left and right inversions counters will be the minimum possible number of inversions.
  - Repeat the process for each test case.
2023-11-06 13:54:57.806 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:54:57.806 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:54:57.815 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:54:57.816 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:54:57.816 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:54:57.816 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'


A solution code generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
0
0
1
0
3
6
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The original code failed to correctly calculate the minimum number of inversions. The problem lies in the way the code is trying to calculate the inversions. It's trying to count the inversions by checking if the current element is greater than the previous one and then incrementing the count. However, this approach is incorrect because it doesn't consider the fact that elements can be added to either the beginning or the end of the deque, which can significantly affect the number of inversions. The code needs to be modified to correctly calculate the minimum number of inversions considering the flexibility of adding elements to either end of the deque.
'

failed_test_fixed_flow:
'
- First, create a deque and two counters for the left and right inversions.
- Iterate over the array from the second element to the last.
- For each element, calculate the left and right inversions if the element is added to the beginning or the end of the deque respectively.
- If the left inversions are less than or equal to the right inversions, add the element to the beginning of the deque and update the left inversions counter.
- Otherwise, add the element to the end of the deque and update the right inversions counter.
- After iterating over all elements, the sum of the left and right inversions counters will be the minimum possible number of inversions.
- Repeat the process for each test case.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-06 13:55:06.609 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def calculate_inversions(n, a):
    from collections import deque
    q = deque()
    q.append(a[0])
    left_inversions = right_inversions = 0
    for i in range(1, n):
        left = right = 0
        if a[i] < q[0]:
            left = q.count(a[i])
        if a[i] > q[-1]:
            right = q.count(a[i])
        if left <= right:
            left_inversions += left
            q.appendleft(a[i])
        else:
            right_inversions += right
            q.append(a[i])
    return left_inversions + right_inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(calculate_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:55:06.609 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:55:06.609 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:55:06.610 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,24 +1,28 @@
-def min_inversions(n, a):
-    b = [0]*(2*n+10)
-    c = [0]*(2*n+10)
-    s = [0]*(2*n+10)
-    for i in range(1, n+1):
-        b[i] = b[i-1]
-        c[i] = c[i-1]
-        s[i] = s[i-1]
-        if a[i-1] > 1:
-            b[i] += c[a[i-1]-1]
-            c[a[i-1]-1] = 0
-        c[a[i-1]] += 1
-        s[i] += b[i]
-    return s[n]
+def calculate_inversions(n, a):
+    from collections import deque
+    q = deque()
+    q.append(a[0])
+    left_inversions = right_inversions = 0
+    for i in range(1, n):
+        left = right = 0
+        if a[i] < q[0]:
+            left = q.count(a[i])
+        if a[i] > q[-1]:
+            right = q.count(a[i])
+        if left <= right:
+            left_inversions += left
+            q.appendleft(a[i])
+        else:
+            right_inversions += right
+            q.append(a[i])
+    return left_inversions + right_inversions
 
 def solve():
     t = int(input())
     for _ in range(t):
         n = int(input())
         a = list(map(int, input().split()))
-        print(min_inversions(n, a))
+        print(calculate_inversions(n, a))
 
 if __name__ == "__main__":
     solve()
2023-11-06 13:55:06.612 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:55:06.612 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:55:06.612 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:55:06.613 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

2023-11-06 13:55:06.613 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
0
1
0
1
2
---
0
0
0
0
0
0
2023-11-06 13:55:06.613 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-06 13:55:06.613 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:58 - counter: 2
2023-11-06 13:55:06.619 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:55:06.619 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:55:06.620 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:55:06.620 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

A Python solution code that was generated for the problem:
'
def calculate_inversions(n, a):
    from collections import deque
    q = deque()
    q.append(a[0])
    left_inversions = right_inversions = 0
    for i in range(1, n):
        left = right = 0
        if a[i] < q[0]:
            left = q.count(a[i])
        if a[i] > q[-1]:
            right = q.count(a[i])
        if left <= right:
            left_inversions += left
            q.appendleft(a[i])
        else:
            right_inversions += right
            q.append(a[i])
    return left_inversions + right_inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(calculate_inversions(n, a))

if __name__ == "__main__":
    solve()
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
0
0
0
0
0
0
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific, and emphasize the fixes, and how do they apply to the input.")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-06 13:55:25.353 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "6\n4\n3 7 5 5\n3\n3 2 1\n3\n3 1 2\n4\n-1 2 2 -1\n4\n4 5 1 3\n5\n1 3 1 3 2\n",
      "expected_output": "2\n0\n1\n0\n1\n2\n",
      "code_output": "0\n0\n0\n0\n0\n0\n"
    }
  ]
what_went_wrong: |-
  The original code is not correctly calculating the number of inversions. It is using the deque's count method to count the number of occurrences of the current element in the deque, and then deciding whether to add the current element to the beginning or the end of the deque based on these counts. However, this approach does not correctly calculate the number of inversions. The count method does not consider the order of the elements in the deque, which is crucial for calculating inversions. Therefore, the code always returns 0 as the number of inversions, which is incorrect.
failed_test_fixed_flow: |-
  - Instead of using the deque's count method, we need to iterate over the deque and count the number of elements that are less than (for adding to the beginning) or greater than (for adding to the end) the current element. This will give us the correct number of inversions that would be added if we add the current element to the beginning or the end of the deque.
  - We then decide whether to add the current element to the beginning or the end of the deque based on which option adds fewer inversions.
  - We keep track of the total number of inversions added in this way.
  - Finally, we return the total number of inversions as the result. This approach correctly calculates the minimum possible number of inversions in the deque after all elements of the array have been processed.
2023-11-06 13:55:25.353 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:55:25.354 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:55:25.362 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:55:25.362 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:55:25.362 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:55:25.362 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'


A solution code generated for the problem:
'
def calculate_inversions(n, a):
    from collections import deque
    q = deque()
    q.append(a[0])
    left_inversions = right_inversions = 0
    for i in range(1, n):
        left = right = 0
        if a[i] < q[0]:
            left = q.count(a[i])
        if a[i] > q[-1]:
            right = q.count(a[i])
        if left <= right:
            left_inversions += left
            q.appendleft(a[i])
        else:
            right_inversions += right
            q.append(a[i])
    return left_inversions + right_inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(calculate_inversions(n, a))

if __name__ == "__main__":
    solve()
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
0
0
0
0
0
0
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The original code is not correctly calculating the number of inversions. It is using the deque's count method to count the number of occurrences of the current element in the deque, and then deciding whether to add the current element to the beginning or the end of the deque based on these counts. However, this approach does not correctly calculate the number of inversions. The count method does not consider the order of the elements in the deque, which is crucial for calculating inversions. Therefore, the code always returns 0 as the number of inversions, which is incorrect.
'

failed_test_fixed_flow:
'
- Instead of using the deque's count method, we need to iterate over the deque and count the number of elements that are less than (for adding to the beginning) or greater than (for adding to the end) the current element. This will give us the correct number of inversions that would be added if we add the current element to the beginning or the end of the deque.
- We then decide whether to add the current element to the beginning or the end of the deque based on which option adds fewer inversions.
- We keep track of the total number of inversions added in this way.
- Finally, we return the total number of inversions as the result. This approach correctly calculates the minimum possible number of inversions in the deque after all elements of the array have been processed.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-06 13:55:35.005 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def calculate_inversions(n, a):
    from collections import deque
    q = deque()
    q.append(a[0])
    inversions = 0
    for i in range(1, n):
        left = right = 0
        for j in range(len(q)):
            if a[i] > q[j]:
                left += 1
            else:
                right += 1
        if left <= right:
            inversions += left
            q.appendleft(a[i])
        else:
            inversions += right
            q.append(a[i])
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(calculate_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:55:35.006 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:55:35.006 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:55:35.006 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -2,20 +2,21 @@
     from collections import deque
     q = deque()
     q.append(a[0])
-    left_inversions = right_inversions = 0
+    inversions = 0
     for i in range(1, n):
         left = right = 0
-        if a[i] < q[0]:
-            left = q.count(a[i])
-        if a[i] > q[-1]:
-            right = q.count(a[i])
+        for j in range(len(q)):
+            if a[i] > q[j]:
+                left += 1
+            else:
+                right += 1
         if left <= right:
-            left_inversions += left
+            inversions += left
             q.appendleft(a[i])
         else:
-            right_inversions += right
+            inversions += right
             q.append(a[i])
-    return left_inversions + right_inversions
+    return inversions
 
 def solve():
     t = int(input())

2023-11-06 13:55:35.010 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:55:35.011 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:55:35.011 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:55:35.011 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

2023-11-06 13:55:35.012 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
0
1
0
1
2
---
2
0
1
1
1
3
2023-11-06 13:55:35.012 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-06 13:55:35.012 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:58 - counter: 3
2023-11-06 13:55:35.024 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:55:35.025 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:55:35.025 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:55:35.025 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

A Python solution code that was generated for the problem:
'
def calculate_inversions(n, a):
    from collections import deque
    q = deque()
    q.append(a[0])
    inversions = 0
    for i in range(1, n):
        left = right = 0
        for j in range(len(q)):
            if a[i] > q[j]:
                left += 1
            else:
                right += 1
        if left <= right:
            inversions += left
            q.appendleft(a[i])
        else:
            inversions += right
            q.append(a[i])
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(calculate_inversions(n, a))

if __name__ == "__main__":
    solve()
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
2
0
1
1
1
3
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific, and emphasize the fixes, and how do they apply to the input.")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-06 13:55:48.411 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "4\n-1 2 2 -1\n",
      "expected_output": "0\n",
      "code_output": "1\n"
    },
    {
      "input": "4\n4 5 1 3\n",
      "expected_output": "1\n",
      "code_output": "1\n"
    },
    {
      "input": "5\n1 3 1 3 2\n",
      "expected_output": "2\n",
      "code_output": "3\n"
    }
  ]
what_went_wrong: |-
  The problem with the code is that it doesn't handle the cases where the array has duplicate elements correctly. When there are duplicate elements in the array, the code doesn't consider the possibility of adding the duplicate to the other end of the deque to minimize the number of inversions. The code simply adds the element to the end or the beginning of the deque based on the number of elements in the deque that are less than or greater than the current element, which doesn't always lead to the minimal number of inversions.
failed_test_fixed_flow: |-
  - First, we need to keep track of the number of elements that are less than and greater than the current element in the deque for each unique element in the array.
  - Then, for each unique element in the array, we calculate the number of inversions if we add all the duplicates of this element to the beginning of the deque and the number of inversions if we add all the duplicates to the end of the deque.
  - We add the duplicates to the position (beginning or end) that results in the minimal number of inversions.
  - Finally, we sum up the number of inversions for all unique elements in the array to get the total number of inversions.
2023-11-06 13:55:48.412 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:55:48.412 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:55:48.429 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:55:48.430 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:55:48.430 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:55:48.430 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'


A solution code generated for the problem:
'
def calculate_inversions(n, a):
    from collections import deque
    q = deque()
    q.append(a[0])
    inversions = 0
    for i in range(1, n):
        left = right = 0
        for j in range(len(q)):
            if a[i] > q[j]:
                left += 1
            else:
                right += 1
        if left <= right:
            inversions += left
            q.appendleft(a[i])
        else:
            inversions += right
            q.append(a[i])
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(calculate_inversions(n, a))

if __name__ == "__main__":
    solve()
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
2
0
1
1
1
3
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The problem with the code is that it doesn't handle the cases where the array has duplicate elements correctly. When there are duplicate elements in the array, the code doesn't consider the possibility of adding the duplicate to the other end of the deque to minimize the number of inversions. The code simply adds the element to the end or the beginning of the deque based on the number of elements in the deque that are less than or greater than the current element, which doesn't always lead to the minimal number of inversions.
'

failed_test_fixed_flow:
'
- First, we need to keep track of the number of elements that are less than and greater than the current element in the deque for each unique element in the array.
- Then, for each unique element in the array, we calculate the number of inversions if we add all the duplicates of this element to the beginning of the deque and the number of inversions if we add all the duplicates to the end of the deque.
- We add the duplicates to the position (beginning or end) that results in the minimal number of inversions.
- Finally, we sum up the number of inversions for all unique elements in the array to get the total number of inversions.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-06 13:55:57.497 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def calculate_inversions(n, a):
    from collections import deque
    q = deque()
    q.append(a[0])
    inversions = 0
    for i in range(1, n):
        left = right = 0
        for j in range(len(q)):
            if a[i] > q[j]:
                left += 1
            else:
                right += 1
        if left <= right:
            inversions += left
            q.appendleft(a[i])
        else:
            inversions += right
            q.append(a[i])
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(calculate_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:55:57.497 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:55:57.498 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:55:57.498 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:

2023-11-06 13:55:57.501 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:55:57.501 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:55:57.501 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:55:57.501 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

2023-11-06 13:55:57.501 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
0
1
0
1
2
---
2
0
1
1
1
3
2023-11-06 13:55:57.502 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-06 13:55:57.502 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:58 - counter: 4
2023-11-06 13:55:57.502 | ERROR    | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:70 - Failed to pass public tests after 3 attempts
2023-11-06 13:55:57.502 | ERROR    | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:106 - Public test - reverting to initial solution
2023-11-06 13:55:57.502 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:115 - ==================
2023-11-06 13:55:57.503 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:116 - Failed to pass all public tests
2023-11-06 13:55:57.503 | INFO     | alpha_codium.gen.stages.run_evaluate_public_tests:run_evaluate_public_tests:117 - ==================
2023-11-06 13:55:57.503 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:19 - --iterate on all ai tests stage--
2023-11-06 13:55:57.505 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:55:57.505 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:55:57.505 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:55:57.506 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

2023-11-06 13:55:57.506 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
0
1
0
1
2
---
0
0
1
0
3
6
2023-11-06 13:55:57.506 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-06 13:55:57.506 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:51 - Failed to pass ai tests. trying to fix code
2023-11-06 13:55:57.512 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:55:57.512 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:55:57.512 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:55:57.513 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

A Python solution code that was generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
0
0
1
0
3
6
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific, and emphasize the fixes, and how do they apply to the input.")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-06 13:56:12.026 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "6\n4\n3 7 5 5\n3\n3 2 1\n3\n3 1 2\n4\n-1 2 2 -1\n4\n4 5 1 3\n5\n1 3 1 3 2\n",
      "expected_output": "2\n0\n1\n0\n1\n2\n",
      "code_output": "0\n0\n1\n0\n3\n6\n"
    }
  ]
what_went_wrong: |-
  The original code solution is not correctly calculating the minimum number of inversions. It seems to be incorrectly updating the counts of elements in the array 'a' and their corresponding inversions in the arrays 'b', 'c', and 's'. This results in an incorrect final count of inversions. The code also does not consider the fact that the elements can be added to either the beginning or the end of the deque, which can affect the number of inversions.
failed_test_fixed_flow: |-
  - First, initialize a deque and a variable to count the number of inversions.
  - For each element in the array, calculate the number of inversions that would result from adding the element to the beginning or the end of the deque.
  - Add the element to the position that results in the minimum number of inversions and update the inversion count.
  - Repeat this process for all elements in the array.
  - The final count of inversions is the minimum number of inversions that can be achieved by adding the elements of the array to the deque in an optimal way.
2023-11-06 13:56:12.026 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:56:12.027 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:56:12.036 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:56:12.036 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:56:12.037 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:56:12.037 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'


A solution code generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

expected output:
2
0
1
0
1
2
code output:
0
0
1
0
3
6
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The original code solution is not correctly calculating the minimum number of inversions. It seems to be incorrectly updating the counts of elements in the array 'a' and their corresponding inversions in the arrays 'b', 'c', and 's'. This results in an incorrect final count of inversions. The code also does not consider the fact that the elements can be added to either the beginning or the end of the deque, which can affect the number of inversions.
'

failed_test_fixed_flow:
'
- First, initialize a deque and a variable to count the number of inversions.
- For each element in the array, calculate the number of inversions that would result from adding the element to the beginning or the end of the deque.
- Add the element to the position that results in the minimum number of inversions and update the inversion count.
- Repeat this process for all elements in the array.
- The final count of inversions is the minimum number of inversions that can be achieved by adding the elements of the array to the deque in an optimal way.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-06 13:56:25.116 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
from collections import deque

def min_inversions(n, a):
    # Initialize deque and inversion count
    d = deque()
    inversions = 0

    # Process each element in the array
    for i in range(n):
        # If deque is empty, simply add the element
        if not d:
            d.append(a[i])
            continue

        # Calculate the number of inversions that would result from adding the element to the beginning or the end of the deque
        if a[i] >= d[0] and a[i] >= d[-1]:
            inversions += min(d.count(d[0]), d.count(d[-1]))
            if d.count(d[0]) <= d.count(d[-1]):
                d.appendleft(a[i])
            else:
                d.append(a[i])
        elif a[i] <= d[0] and a[i] <= d[-1]:
            inversions += min(n - i - d.count(d[0]), n - i - d.count(d[-1]))
            if n - i - d.count(d[0]) <= n - i - d.count(d[-1]):
                d.appendleft(a[i])
            else:
                d.append(a[i])
        elif a[i] >= d[0]:
            inversions += d.count(d[0])
            d.appendleft(a[i])
        else:
            inversions += n - i - d.count(d[-1])
            d.append(a[i])

    # Return the final count of inversions
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:56:25.117 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:56:25.118 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:56:25.119 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,21 +1,38 @@
-def calculate_inversions(n, a):
-    from collections import deque
-    q = deque()
-    q.append(a[0])
+from collections import deque
+
+def min_inversions(n, a):
+    # Initialize deque and inversion count
+    d = deque()
     inversions = 0
-    for i in range(1, n):
-        left = right = 0
-        for j in range(len(q)):
-            if a[i] > q[j]:
-                left += 1
+
+    # Process each element in the array
+    for i in range(n):
+        # If deque is empty, simply add the element
+        if not d:
+            d.append(a[i])
+            continue
+
+        # Calculate the number of inversions that would result from adding the element to the beginning or the end of the deque
+        if a[i] >= d[0] and a[i] >= d[-1]:
+            inversions += min(d.count(d[0]), d.count(d[-1]))
+            if d.count(d[0]) <= d.count(d[-1]):
+                d.appendleft(a[i])
             else:
-                right += 1
-        if left <= right:
-            inversions += left
-            q.appendleft(a[i])
+                d.append(a[i])
+        elif a[i] <= d[0] and a[i] <= d[-1]:
+            inversions += min(n - i - d.count(d[0]), n - i - d.count(d[-1]))
+            if n - i - d.count(d[0]) <= n - i - d.count(d[-1]):
+                d.appendleft(a[i])
+            else:
+                d.append(a[i])
+        elif a[i] >= d[0]:
+            inversions += d.count(d[0])
+            d.appendleft(a[i])
         else:
-            inversions += right
-            q.append(a[i])
+            inversions += n - i - d.count(d[-1])
+            d.append(a[i])
+
+    # Return the final count of inversions
     return inversions
 
 def solve():
@@ -23,7 +40,7 @@
     for _ in range(t):
         n = int(input())
         a = list(map(int, input().split()))
-        print(calculate_inversions(n, a))
+        print(min_inversions(n, a))
 
 if __name__ == "__main__":
     solve()
2023-11-06 13:56:25.124 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:56:25.124 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:56:25.125 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:56:25.125 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2

2023-11-06 13:56:25.125 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
0
1
0
1
2
---
2
1
2
1
3
4
2023-11-06 13:56:25.125 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=False. 
2023-11-06 13:56:25.126 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:64 - Failed to pass ai tests after trying to fix code. reverting to last solution
2023-11-06 13:56:25.129 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:56:25.129 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:56:25.129 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:56:25.130 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
1
1

2023-11-06 13:56:25.130 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-06 13:56:25.130 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:56:25.131 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-06 13:56:25.133 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:56:25.134 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:56:25.134 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:56:25.135 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
2
1 2

2023-11-06 13:56:25.135 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
1
2023-11-06 13:56:25.135 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-06 13:56:25.136 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:51 - Failed to pass ai tests. trying to fix code
2023-11-06 13:56:25.144 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:56:25.144 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:56:25.144 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:56:25.144 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

A Python solution code that was generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
1
2
1 2

expected output:
0
code output:
1
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific, and emphasize the fixes, and how do they apply to the input.")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-06 13:56:40.859 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "1\n2\n1 2\n",
      "expected_output": "0\n",
      "code_output": "1\n"
    }
  ]
what_went_wrong: |-
  The problem with the code solution is that it incorrectly calculates the number of inversions. The code uses an array 'b' to store the cumulative sum of the number of inversions, and an array 'c' to store the count of each element in the array 'a'. However, the code incorrectly increments the count of inversions for each element greater than 1 in the array 'a', even when there is no inversion. This leads to an overestimation of the number of inversions. For example, in the failed test case, the array 'a' is [1, 2], which has no inversions, but the code incorrectly calculates one inversion.
failed_test_fixed_flow: |-
  - Initialize arrays 'b', 'c', and 's' of size 2n+10 with all elements as 0. 'b' will store the cumulative sum of the number of inversions, 'c' will store the count of each element in the array 'a', and 's' will store the cumulative sum of 'b'.
  - Iterate over the array 'a' from the first element to the last.
  - For each element in 'a', update 'b', 'c', and 's' as follows:
    - If the element is greater than 1, increment 'b' by the count of elements less than the current element in 'c' (i.e., 'c'[element-1]), and reset the count of elements less than the current element in 'c' to 0.
    - Increment the count of the current element in 'c'.
    - Add the current value of 'b' to 's'.
  - The fix should be to only increment 'b' by the count of elements less than the current element in 'c' if the current element is greater than the previous element in 'a'. This ensures that we only count inversions where the current element is greater than a previous element.
  - After processing all elements in 'a', return the last element in 's', which is the cumulative sum of the number of inversions.
2023-11-06 13:56:40.860 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:56:40.860 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:56:40.876 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:56:40.877 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:56:40.877 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:56:40.877 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'


A solution code generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
1
2
1 2

expected output:
0
code output:
1
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The problem with the code solution is that it incorrectly calculates the number of inversions. The code uses an array 'b' to store the cumulative sum of the number of inversions, and an array 'c' to store the count of each element in the array 'a'. However, the code incorrectly increments the count of inversions for each element greater than 1 in the array 'a', even when there is no inversion. This leads to an overestimation of the number of inversions. For example, in the failed test case, the array 'a' is [1, 2], which has no inversions, but the code incorrectly calculates one inversion.
'

failed_test_fixed_flow:
'
- Initialize arrays 'b', 'c', and 's' of size 2n+10 with all elements as 0. 'b' will store the cumulative sum of the number of inversions, 'c' will store the count of each element in the array 'a', and 's' will store the cumulative sum of 'b'.
- Iterate over the array 'a' from the first element to the last.
- For each element in 'a', update 'b', 'c', and 's' as follows:
  - If the element is greater than 1, increment 'b' by the count of elements less than the current element in 'c' (i.e., 'c'[element-1]), and reset the count of elements less than the current element in 'c' to 0.
  - Increment the count of the current element in 'c'.
  - Add the current value of 'b' to 's'.
- The fix should be to only increment 'b' by the count of elements less than the current element in 'c' if the current element is greater than the previous element in 'a'. This ensures that we only count inversions where the current element is greater than a previous element.
- After processing all elements in 'a', return the last element in 's', which is the cumulative sum of the number of inversions.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-06 13:56:56.275 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def min_inversions(n, a):
    # Initialize arrays 'b', 'c', and 's' of size 2n+10 with all elements as 0.
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    
    # Iterate over the array 'a' from the first element to the last.
    for i in range(1, n+1):
        # Update 'b', 'c', and 's' as follows:
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        
        # Only increment 'b' by the count of elements less than the current element in 'c' if the current element is greater than the previous element in 'a'.
        if a[i-1] > 1 and a[i-1] > a[i-2]:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
            
        # Increment the count of the current element in 'c'.
        c[a[i-1]] += 1
        
        # Add the current value of 'b' to 's'.
        s[i] += b[i]
        
    # Return the last element in 's', which is the cumulative sum of the number of inversions.
    return s[n]

def solve():
    # Read the number of test cases.
    t = int(input())
    
    # Process each test case.
    for _ in range(t):
        # Read the size of the array.
        n = int(input())
        
        # Read the elements of the array.
        a = list(map(int, input().split()))
        
        # Print the minimum possible number of inversions.
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:56:56.275 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:56:56.275 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:56:56.276 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,29 +1,44 @@
-def calculate_inversions(n, a):
-    from collections import deque
-    q = deque()
-    q.append(a[0])
-    inversions = 0
-    for i in range(1, n):
-        left = right = 0
-        for j in range(len(q)):
-            if a[i] > q[j]:
-                left += 1
-            else:
-                right += 1
-        if left <= right:
-            inversions += left
-            q.appendleft(a[i])
-        else:
-            inversions += right
-            q.append(a[i])
-    return inversions
+def min_inversions(n, a):
+    # Initialize arrays 'b', 'c', and 's' of size 2n+10 with all elements as 0.
+    b = [0]*(2*n+10)
+    c = [0]*(2*n+10)
+    s = [0]*(2*n+10)
+    
+    # Iterate over the array 'a' from the first element to the last.
+    for i in range(1, n+1):
+        # Update 'b', 'c', and 's' as follows:
+        b[i] = b[i-1]
+        c[i] = c[i-1]
+        s[i] = s[i-1]
+        
+        # Only increment 'b' by the count of elements less than the current element in 'c' if the current element is greater than the previous element in 'a'.
+        if a[i-1] > 1 and a[i-1] > a[i-2]:
+            b[i] += c[a[i-1]-1]
+            c[a[i-1]-1] = 0
+            
+        # Increment the count of the current element in 'c'.
+        c[a[i-1]] += 1
+        
+        # Add the current value of 'b' to 's'.
+        s[i] += b[i]
+        
+    # Return the last element in 's', which is the cumulative sum of the number of inversions.
+    return s[n]
 
 def solve():
+    # Read the number of test cases.
     t = int(input())
+    
+    # Process each test case.
     for _ in range(t):
+        # Read the size of the array.
         n = int(input())
+        
+        # Read the elements of the array.
         a = list(map(int, input().split()))
-        print(calculate_inversions(n, a))
+        
+        # Print the minimum possible number of inversions.
+        print(min_inversions(n, a))
 
 if __name__ == "__main__":
     solve()
2023-11-06 13:56:56.278 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:56:56.278 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:56:56.278 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:56:56.279 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
2
1 2

2023-11-06 13:56:56.279 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
1
2023-11-06 13:56:56.279 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-06 13:56:56.279 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:64 - Failed to pass ai tests after trying to fix code. reverting to last solution
2023-11-06 13:56:56.280 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:56:56.280 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:56:56.281 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:56:56.281 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
3
1 2 3

2023-11-06 13:56:56.281 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
4
2023-11-06 13:56:56.281 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-06 13:56:56.281 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:51 - Failed to pass ai tests. trying to fix code
2023-11-06 13:56:56.287 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:56:56.287 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:56:56.287 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:56:56.287 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

A Python solution code that was generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
1
3
1 2 3

expected output:
0
code output:
4
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific, and emphasize the fixes, and how do they apply to the input.")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-06 13:57:07.413 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '1\n3\n1 2 3\n', expected_output: '0\n', code_output: '4\n'}
what_went_wrong: |-
  The code is using the array values as indices for the auxiliary arrays b, c, and s. This approach is incorrect because the array values can be negative or larger than the size of these auxiliary arrays, leading to index errors. Moreover, the code is not correctly calculating the number of inversions. It is incrementing the count of inversions for every element that is larger than 1, which is not the correct condition for an inversion. An inversion occurs when an element is larger than another element that comes after it in the sequence, not simply when it is larger than 1.
failed_test_fixed_flow: |-
  - Initialize a deque and a variable to keep track of the number of inversions.
  - Iterate over the array from the end to the beginning.
  - For each element, calculate the number of elements in the deque that are smaller and larger than it.
  - Add the smaller number to the count of inversions.
  - Depending on which number was smaller, add the current element to the beginning or the end of the deque.
  - Repeat this process for all elements in the array.
  - The count of inversions at the end of this process will be the minimum possible number of inversions.
2023-11-06 13:57:07.414 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:57:07.414 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:57:07.424 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:57:07.424 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:57:07.424 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:57:07.424 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'


A solution code generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
1
3
1 2 3

expected output:
0
code output:
4
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The code is using the array values as indices for the auxiliary arrays b, c, and s. This approach is incorrect because the array values can be negative or larger than the size of these auxiliary arrays, leading to index errors. Moreover, the code is not correctly calculating the number of inversions. It is incrementing the count of inversions for every element that is larger than 1, which is not the correct condition for an inversion. An inversion occurs when an element is larger than another element that comes after it in the sequence, not simply when it is larger than 1.
'

failed_test_fixed_flow:
'
- Initialize a deque and a variable to keep track of the number of inversions.
- Iterate over the array from the end to the beginning.
- For each element, calculate the number of elements in the deque that are smaller and larger than it.
- Add the smaller number to the count of inversions.
- Depending on which number was smaller, add the current element to the beginning or the end of the deque.
- Repeat this process for all elements in the array.
- The count of inversions at the end of this process will be the minimum possible number of inversions.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-06 13:57:15.570 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
from collections import deque

def count_inversions(n, a):
    a = deque(a)
    b = deque()
    inversions = 0
    while a:
        left = a[0]
        right = a[-1]
        left_count = sum(i < left for i in b)
        right_count = sum(i < right for i in b)
        if left_count <= right_count:
            inversions += left_count
            b.appendleft(a.popleft())
        else:
            inversions += right_count
            b.append(a.pop())
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(count_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:57:15.570 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:57:15.571 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:57:15.571 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,21 +1,20 @@
-def calculate_inversions(n, a):
-    from collections import deque
-    q = deque()
-    q.append(a[0])
+from collections import deque
+
+def count_inversions(n, a):
+    a = deque(a)
+    b = deque()
     inversions = 0
-    for i in range(1, n):
-        left = right = 0
-        for j in range(len(q)):
-            if a[i] > q[j]:
-                left += 1
-            else:
-                right += 1
-        if left <= right:
-            inversions += left
-            q.appendleft(a[i])
+    while a:
+        left = a[0]
+        right = a[-1]
+        left_count = sum(i < left for i in b)
+        right_count = sum(i < right for i in b)
+        if left_count <= right_count:
+            inversions += left_count
+            b.appendleft(a.popleft())
         else:
-            inversions += right
-            q.append(a[i])
+            inversions += right_count
+            b.append(a.pop())
     return inversions
 
 def solve():
@@ -23,7 +22,7 @@
     for _ in range(t):
         n = int(input())
         a = list(map(int, input().split()))
-        print(calculate_inversions(n, a))
+        print(count_inversions(n, a))
 
 if __name__ == "__main__":
     solve()
2023-11-06 13:57:15.574 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:57:15.574 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:57:15.574 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:57:15.575 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
3
1 2 3

2023-11-06 13:57:15.575 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
3
2023-11-06 13:57:15.575 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-06 13:57:15.575 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:64 - Failed to pass ai tests after trying to fix code. reverting to last solution
2023-11-06 13:57:15.577 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:57:15.577 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:57:15.577 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:57:15.577 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
4
1 2 3 4

2023-11-06 13:57:15.578 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
10
2023-11-06 13:57:15.578 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None. 
2023-11-06 13:57:15.578 | ERROR    | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:51 - Failed to pass ai tests. trying to fix code
2023-11-06 13:57:15.585 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:57:15.585 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:57:15.585 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:57:15.585 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a Python code solution.

problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'

self-reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'

A Python solution code that was generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'


However, when running the following input example, the code failed to produce the expected output:
'
test input:
1
4
1 2 3 4

expected output:
0
code output:
10
====================
====================
'


Your goal is to analyze the code and the error, and propose a fix so the code will produce the expected output for the provided input example.
The fix should keep the solution robust, and work for all other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in words, what was the problem with the code solution, and how should it be fix. Be as specific as possible. Don't generate actuall code.")
    failed_test_fixed_flow: str = Field(description="describe shortly, in bullet points, how the fixed flow will calculate the correct output, step-by-step. be specific, and emphasize the fixes, and how do they apply to the input.")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
failed_test_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


Answer:
```yaml
2023-11-06 13:57:27.727 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  [
    {
      "input": "1\n4\n1 2 3 4\n",
      "expected_output": "0\n",
      "code_output": "10\n"
    }
  ]
what_went_wrong: |-
  The original solution is incorrectly calculating the number of inversions. It seems to be counting the number of elements that are smaller than the current element and are located before it in the array, which is not the correct definition of inversions. An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j. The original solution also does not take into account the fact that elements can be added to either the beginning or the end of the deque, which can affect the number of inversions.
failed_test_fixed_flow: |-
  - Initialize a deque and a counter for the number of inversions.
  - For each element in the array:
    - If the deque is empty, add the element to the deque.
    - Otherwise, compare the element with the first and last elements of the deque.
    - If adding the element to the beginning of the deque results in fewer inversions, add it to the beginning and update the counter.
    - Otherwise, add the element to the end of the deque and update the counter.
  - Return the counter as the minimum possible number of inversions.
2023-11-06 13:57:27.728 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:57:27.728 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:57:27.738 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-06 13:57:27.738 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-06 13:57:27.738 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-06 13:57:27.738 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
you are given a code contest problem, self-reflection on the problem, and a possible Python code solution to the problem:

=====================================
problem description:
'
In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n].

Let us consider an empty [deque](https://tinyurl.com/pfeucbux) (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [3, 4, 4] currently in the deque, adding an element 1 to the beginning will produce the sequence [\color{red}{1}, 3, 4, 4], and adding the same element to the end will produce [3, 4, 4, \color{red}{1}].

The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque, you may choose whether to add it to the beginning or to the end.

For example, if we consider an array a = [3, 7, 5, 5], one of the possible sequences of actions looks like this:    1. |  add 3 to the beginning of the deque: |  deque has a sequence [\color{red}{3}] in it;   
---|---|---  
  2. |  add 7 to the end of the deque: |  deque has a sequence [3, \color{red}{7}] in it;   
  3. |  add 5 to the end of the deque: |  deque has a sequence [3, 7, \color{red}{5}] in it;   
  4. |  add 5 to the beginning of the deque: |  deque has a sequence [\color{red}{5}, 3, 7, 5] in it;   
  
Find the minimal possible number of inversions in the deque after the whole array is processed. 

An inversion in sequence d is a pair of indices (i, j) such that i < j and d_i > d_j. For example, the array d = [5, 3, 7, 5] has exactly two inversions — (1, 2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
'


self reflection on the problem:
'
- The problem is about optimizing an array using a deque (double-ended queue) data structure.
- We are given an array of integers and we need to add each element to either the beginning or the end of the deque.
- The goal is to minimize the number of inversions in the deque after all elements of the array have been processed.
- An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j.
- The input consists of multiple test cases. Each test case includes the size of the array and the array elements.
- The output should be the minimum possible number of inversions for each test case.
'


A solution code generated for the problem:
'
def min_inversions(n, a):
    b = [0]*(2*n+10)
    c = [0]*(2*n+10)
    s = [0]*(2*n+10)
    for i in range(1, n+1):
        b[i] = b[i-1]
        c[i] = c[i-1]
        s[i] = s[i-1]
        if a[i-1] > 1:
            b[i] += c[a[i-1]-1]
            c[a[i-1]-1] = 0
        c[a[i-1]] += 1
        s[i] += b[i]
    return s[n]

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
'
=====================================


However, when running the input-output example test, the code failed to produce the expected output:

=====================================
Error message when running the 'solution code':
'
test input:
1
4
1 2 3 4

expected output:
0
code output:
10
====================
====================
'
=====================================


We analyzed the error message, and concluded that the following went wrong:

what went wrong:
'
The original solution is incorrectly calculating the number of inversions. It seems to be counting the number of elements that are smaller than the current element and are located before it in the array, which is not the correct definition of inversions. An inversion is a pair of indices (i, j) where i < j and the element at index i is greater than the element at index j. The original solution also does not take into account the fact that elements can be added to either the beginning or the end of the deque, which can affect the number of inversions.
'

failed_test_fixed_flow:
'
- Initialize a deque and a counter for the number of inversions.
- For each element in the array:
  - If the deque is empty, add the element to the deque.
  - Otherwise, compare the element with the first and last elements of the deque.
  - If adding the element to the beginning of the deque results in fewer inversions, add it to the beginning and update the counter.
  - Otherwise, add the element to the end of the deque and update the counter.
- Return the counter as the minimum possible number of inversions.
'
=====================================


Using the provided analysis above, you need generate a fixed solution code, that will pass all the tests.
Additional guidelines for generating the fixed code:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality
- If the change is small, try adding comments to relevant part, explaining what was fixed

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.


Answer:
```python
2023-11-06 13:57:39.906 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
from collections import deque

def min_inversions(n, a):
    # Initialize a deque and a counter for the number of inversions.
    d = deque()
    inversions = 0

    # For each element in the array:
    for i in range(n):
        # If the deque is empty, add the element to the deque.
        if not d:
            d.append(a[i])
        else:
            # Otherwise, compare the element with the first and last elements of the deque.
            # If adding the element to the beginning of the deque results in fewer inversions, add it to the beginning and update the counter.
            if a[i] <= d[0]:
                inversions += len([x for x in d if x < a[i]])
                d.appendleft(a[i])
            # Otherwise, add the element to the end of the deque and update the counter.
            else:
                inversions += len([x for x in d if x > a[i]])
                d.append(a[i])

    # Return the counter as the minimum possible number of inversions.
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:57:39.906 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-06 13:57:39.907 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-06 13:57:39.907 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
--- 
+++ 
@@ -1,21 +1,27 @@
-def calculate_inversions(n, a):
-    from collections import deque
-    q = deque()
-    q.append(a[0])
+from collections import deque
+
+def min_inversions(n, a):
+    # Initialize a deque and a counter for the number of inversions.
+    d = deque()
     inversions = 0
-    for i in range(1, n):
-        left = right = 0
-        for j in range(len(q)):
-            if a[i] > q[j]:
-                left += 1
+
+    # For each element in the array:
+    for i in range(n):
+        # If the deque is empty, add the element to the deque.
+        if not d:
+            d.append(a[i])
+        else:
+            # Otherwise, compare the element with the first and last elements of the deque.
+            # If adding the element to the beginning of the deque results in fewer inversions, add it to the beginning and update the counter.
+            if a[i] <= d[0]:
+                inversions += len([x for x in d if x < a[i]])
+                d.appendleft(a[i])
+            # Otherwise, add the element to the end of the deque and update the counter.
             else:
-                right += 1
-        if left <= right:
-            inversions += left
-            q.appendleft(a[i])
-        else:
-            inversions += right
-            q.append(a[i])
+                inversions += len([x for x in d if x > a[i]])
+                d.append(a[i])
+
+    # Return the counter as the minimum possible number of inversions.
     return inversions
 
 def solve():
@@ -23,7 +29,7 @@
     for _ in range(t):
         n = int(input())
         a = list(map(int, input().split()))
-        print(calculate_inversions(n, a))
+        print(min_inversions(n, a))
 
 if __name__ == "__main__":
     solve()
2023-11-06 13:57:39.910 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:57:39.910 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:57:39.910 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:57:39.910 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
4
1 2 3 4

2023-11-06 13:57:39.910 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-06 13:57:39.910 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:57:39.912 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:57:39.912 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:57:39.912 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:57:39.913 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
1
1

2023-11-06 13:57:39.913 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-06 13:57:39.913 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:57:39.913 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:78 - Passed all ai tests after trying to fix code. using new solution
2023-11-06 13:57:39.914 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:57:39.915 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:57:39.915 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:57:39.915 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
5
5 4 3 2 1

2023-11-06 13:57:39.915 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-06 13:57:39.915 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:57:39.915 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-06 13:57:39.917 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:57:39.917 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:57:39.917 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:57:39.917 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
6
6 5 4 3 2 1

2023-11-06 13:57:39.917 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-06 13:57:39.917 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:57:39.917 | INFO     | alpha_codium.gen.stages.run_evaluate_all_ai_tests:run_evaluate_all_ai_tests:43 - Passed ai tests without code fixing. adding to passed tests list
2023-11-06 13:57:39.918 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:126 - testing solution on private tests with prediction:
from collections import deque

def min_inversions(n, a):
    # Initialize a deque and a counter for the number of inversions.
    d = deque()
    inversions = 0

    # For each element in the array:
    for i in range(n):
        # If the deque is empty, add the element to the deque.
        if not d:
            d.append(a[i])
        else:
            # Otherwise, compare the element with the first and last elements of the deque.
            # If adding the element to the beginning of the deque results in fewer inversions, add it to the beginning and update the counter.
            if a[i] <= d[0]:
                inversions += len([x for x in d if x < a[i]])
                d.appendleft(a[i])
            # Otherwise, add the element to the end of the deque and update the counter.
            else:
                inversions += len([x for x in d if x > a[i]])
                d.append(a[i])

    # Return the counter as the minimum possible number of inversions.
    return inversions

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        print(min_inversions(n, a))

if __name__ == "__main__":
    solve()
2023-11-06 13:57:39.920 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 - 
2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 - 
2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
1
-1000000000

2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
1
5
999999996 999999997 1000000000 999999998 999999999

2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
2
---
2
2023-11-06 13:57:39.921 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-1 :: status=ProgramStatus.kSuccess, passed=True
2023-11-06 13:57:39.922 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:161 - =====================================
2023-11-06 13:57:39.922 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:162 - test_passed: 2, test_failed: 0
2023-11-06 13:57:39.922 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:163 - =====================================

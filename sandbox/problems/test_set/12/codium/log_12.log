2023-11-03 21:23:41.286 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:192 - problem_name: 1575_M. Managing Telephone Poles
2023-11-03 21:23:41.289 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:195 - problem['cf_tags']:
['data structures', 'geometry']
2023-11-03 21:23:41.291 | INFO     | alpha_codium.gen.coding_competitor:run:66 - Running code contests competitor, model gpt-4
2023-11-03 21:23:41.292 | INFO     | alpha_codium.gen.stages.utils:set_configurations:16 - recording_path: ./code_contests/1575_M. Managing Telephone Poles/gpt-4/
do_record: True
use_record: False
2023-11-03 21:23:41.292 | INFO     | alpha_codium.gen.stages.run_self_reflect:run_self_reflect:13 - --reflection stage--
2023-11-03 21:23:41.295 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:23:41.295 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:23:41.295 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-03 21:23:41.295 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You given a code contest problem:

problem name: '1575_M. Managing Telephone Poles'


problem description:
'
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.

There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.

For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.

To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
'

Your goal is reflect on the problem, and describe it in your own words.
You should also present possible solutions to the problem.
Make sure to fully address the problem constraints.
Double-check the solutions and test them on multiple edge cases and happy paths, including the provided input-output examples.

The output must be a YAML object equivalent to type $ProblemReflection, according to the following Pydantic definitions:
'
class Solution(BaseModel):
    name: str = Field(description="The name of the solution.")
    content: str = Field(description="A description of the solution.")
    labels: List[str] = Field(description="A list of labels for the solution [e.g. binary search, dynamic programming, tree traversal, greedy, ...]")
    complexity: str = Field(description="The complexity of the solution.")


class ProblemReflection(BaseModel):
    self_description: str = Field(description="Describe the problem in your own words, in bullet points. Address the problem goal, inputs, outputs, constraints, and other relevant details.")
    possible_solutions: List[Solution] = Field(min_items=3, max_items=3, description="A list of possible solutions to the problem.")
'

Example YAML output:
```yaml
self_description: |
    ...
possible_solutions:
- name: ...
  content: |
    ...
  labels
  - ...
  - ...
  complexity: |
    ...
 ```


Answer:
```yaml
2023-11-03 21:24:04.507 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
self_description: |
  - The problem is about a city represented as a grid where there are some telephone poles. The grid is of size (n + 1) x (m + 1) and a telephone pole is present at a point (x, y) if a_{x, y} = 1.
  - The task is to calculate the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
  - The input consists of the size of the grid (n, m) and the grid itself, represented as a matrix of 0s and 1s, where 1 indicates the presence of a telephone pole.
  - The output is an integer, the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
possible_solutions:
- name: Brute Force
  content: |
    The simplest approach is to calculate the Euclidean distance from each point in the grid to every other point and keep track of the minimum distance. This distance is then squared and added to a sum. This process is repeated for all points in the grid.
  labels:
    - Brute Force
  complexity: |
    The time complexity of this solution is O(n^2 * m^2) because for each point in the grid, we are calculating the distance to every other point.
- name: Dynamic Programming
  content: |
    A more efficient approach is to use dynamic programming. We can start by initializing a dp array with a large value at all positions except where there is a telephone pole (where we put 0). Then, we iterate over the grid in both directions (left to right and top to bottom, then right to left and bottom to top) and for each cell, we take the minimum value between the current cell and the adjacent cell plus the distance between them. The final dp array will contain the minimum distance from each cell to a telephone pole. We then square these distances and sum them up.
  labels:
    - Dynamic Programming
  complexity: |
    The time complexity of this solution is O(n*m) because we are iterating over the grid twice.
- name: Breadth-First Search
  content: |
    Another approach is to use a breadth-first search (BFS) algorithm. We can start by adding all the positions of the telephone poles to a queue. Then, we perform a BFS from each of these positions. For each cell we visit, we calculate the distance from the cell to the telephone pole and update the distance in the grid if it is smaller than the current distance. Finally, we square these distances and sum them up.
  labels:
    - Breadth-First Search
  complexity: |
    The time complexity of this solution is O(n*m) because in the worst case, we may need to visit all the cells in the grid.
2023-11-03 21:24:04.507 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:24:04.507 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:24:04.511 | INFO     | alpha_codium.gen.stages.run_choose_best_solution:run_choose_best_solution:13 - --choose best solution stage--
2023-11-03 21:24:04.515 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:24:04.515 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:24:04.515 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:

2023-11-03 21:24:04.515 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
You are given a code contest problem, self-reflection on the problem, and a list of possible solutions.

problem name: '1575_M. Managing Telephone Poles'


problem description:
'
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.

There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.

For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.

To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
'


self reflection:
'
- The problem is about a city represented as a grid where there are some telephone poles. The grid is of size (n + 1) x (m + 1) and a telephone pole is present at a point (x, y) if a_{x, y} = 1.
- The task is to calculate the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
- The input consists of the size of the grid (n, m) and the grid itself, represented as a matrix of 0s and 1s, where 1 indicates the presence of a telephone pole.
- The output is an integer, the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
'

possible solutions:
'
- name: Brute Force
  content: |
    The simplest approach is to calculate the Euclidean distance from each point in the grid to every other point and keep track of the minimum distance. This distance is then squared and added to a sum. This process is repeated for all points in the grid.
  labels:
    - Brute Force
  complexity: |
    The time complexity of this solution is O(n^2 * m^2) because for each point in the grid, we are calculating the distance to every other point.
- name: Dynamic Programming
  content: |
    A more efficient approach is to use dynamic programming. We can start by initializing a dp array with a large value at all positions except where there is a telephone pole (where we put 0). Then, we iterate over the grid in both directions (left to right and top to bottom, then right to left and bottom to top) and for each cell, we take the minimum value between the current cell and the adjacent cell plus the distance between them. The final dp array will contain the minimum distance from each cell to a telephone pole. We then square these distances and sum them up.
  labels:
    - Dynamic Programming
  complexity: |
    The time complexity of this solution is O(n*m) because we are iterating over the grid twice.
- name: Breadth-First Search
  content: |
    Another approach is to use a breadth-first search (BFS) algorithm. We can start by adding all the positions of the telephone poles to a queue. Then, we perform a BFS from each of these positions. For each cell we visit, we calculate the distance from the cell to the telephone pole and update the distance in the grid if it is smaller than the current distance. Finally, we square these distances and sum them up.
  labels:
    - Breadth-First Search
  complexity: |
    The time complexity of this solution is O(n*m) because in the worst case, we may need to visit all the cells in the grid.
'

Using these inputs, you goal is to choose the best solution to the code contest problem.
Don't just pick the most efficient solution. The main consideration is that the solution can fully solve the problem, in a simple and robust way. Prefer dynamic programming if possible.
Be critical - the provided solutions may be wrong, or not fully solve the problem.
Double-check the best solution, and simulate running it on multiple edge cases and happy paths, including the provided input-output examples.
Mke sure the best solution has a reasonable runtime. It should run in less than 3 second on a modern computer.

The output must be a YAML object equivalent to type $ProblemSolution, according to the following Pydantic definitions:
'
class ProblemSolution(BaseModel):
    name: str = Field(description="The name of the best solution")
    content: str = Field(description="The content of the best solution")
    labels: List[str] = Field(description="A list of labels for the solution. For example (partial list): brute force, binary search, dynamic programming, trees, greedy, combinatorics, dfs, graphs, constructive algorithms, math, data structures, geometry, number theory, ...")
    complexity: str = Field(description="The complexity of the solution.")
    why: str = Field(description="why is this the best solution?")
    flow: str = Field(description="detailed description of the flow of the solution, in bullet points")
    input_output_examples_flow: str = Field(description="describe how the proposed flow will lead to getting the expected output for the provided input examples")
'


Example YAML output:
```yaml
name: ...
content: |
  ...
labels:
  - ...
  - ...
complexity: ...
why: |
  ...
flow: |
  - ...
  - ...
  - ...
input_output_examples_flow: |
  - ...
  - ...
  - ...
```

Answer:
```yaml
2023-11-03 21:24:31.471 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
name: Dynamic Programming
content: |
  A more efficient approach is to use dynamic programming. We can start by initializing a dp array with a large value at all positions except where there is a telephone pole (where we put 0). Then, we iterate over the grid in both directions (left to right and top to bottom, then right to left and bottom to top) and for each cell, we take the minimum value between the current cell and the adjacent cell plus the distance between them. The final dp array will contain the minimum distance from each cell to a telephone pole. We then square these distances and sum them up.
labels:
  - Dynamic Programming
complexity: |
  The time complexity of this solution is O(n*m) because we are iterating over the grid twice.
why: |
  This solution is the best because it fully solves the problem and does so efficiently. It uses dynamic programming to calculate the minimum distance from each cell to a telephone pole, which is a more efficient approach than brute force or BFS. This solution also has a reasonable runtime, as it only needs to iterate over the grid twice.
flow: |
  - Initialize a dp array with a large value at all positions except where there is a telephone pole (where we put 0).
  - Iterate over the grid in both directions (left to right and top to bottom, then right to left and bottom to top).
  - For each cell, take the minimum value between the current cell and the adjacent cell plus the distance between them.
  - The final dp array will contain the minimum distance from each cell to a telephone pole.
  - Square these distances and sum them up to get the final answer.
input_output_examples_flow: |
  - For the first example, the dp array after the first iteration would be [[0, 1, 0], [1, 2, 1], [2, 3, 2]]. After the second iteration, it would be [[0, 1, 0], [1, 2, 1], [2, 3, 2]]. Squaring these values and summing them up gives 18.
  - For the second example, the dp array after the first iteration would be [[0, 1, 2, 3, 0], [1, 2, 3, 4, 1], [0, 1, 2, 3, 2], [1, 2, 3, 0, 1], [2, 1, 0, 1, 2], [3, 2, 1, 2, 0]]. After the second iteration, it would be [[0, 1, 2, 3, 0], [1, 2, 1, 2, 1], [0, 1, 2, 1, 2], [1, 2, 1, 0, 1], [2, 1, 0, 1, 2], [3, 2, 1, 2, 0]]. Squaring these values and summing them up gives 36.
2023-11-03 21:24:31.471 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:24:31.471 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:24:31.475 | INFO     | alpha_codium.gen.stages.run_initial_solve:run_initial_solve:13 - --solve stage--
2023-11-03 21:24:31.480 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:24:31.480 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:24:31.480 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:
You are an expert Python programmer.

You are given a code contest problem, self-reflection on the problem, and a description of the solution, in words.
Your goal is to generate a valid Python code that correctly solves the problem.

guidelines:
- You must divide the code into small sub-functions, with meaningful names and functionality. Variables names should also be meaningful.
- The code must have a reasonable runtime and memory complexity
- Always double-check the solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure to include all the necessary module imports, properly initialize the variables, and address the problem constraints.
- The code needs to be self-contained, and executable as-is.
- emphasis not accessing an index that is out of the range of a list

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

2023-11-03 21:24:31.480 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
problem description:
'
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.

There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.

For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.

To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
'


self reflection:
'
- The problem is about a city represented as a grid where there are some telephone poles. The grid is of size (n + 1) x (m + 1) and a telephone pole is present at a point (x, y) if a_{x, y} = 1.
- The task is to calculate the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
- The input consists of the size of the grid (n, m) and the grid itself, represented as a matrix of 0s and 1s, where 1 indicates the presence of a telephone pole.
- The output is an integer, the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.

'

propose solution:
'
name: Dynamic Programming
content: |
  A more efficient approach is to use dynamic programming. We can start by initializing a dp array with a large value at all positions except where there is a telephone pole (where we put 0). Then, we iterate over the grid in both directions (left to right and top to bottom, then right to left and bottom to top) and for each cell, we take the minimum value between the current cell and the adjacent cell plus the distance between them. The final dp array will contain the minimum distance from each cell to a telephone pole. We then square these distances and sum them up.
labels:
  - Dynamic Programming
complexity: |
  The time complexity of this solution is O(n*m) because we are iterating over the grid twice.
why: |
  This solution is the best because it fully solves the problem and does so efficiently. It uses dynamic programming to calculate the minimum distance from each cell to a telephone pole, which is a more efficient approach than brute force or BFS. This solution also has a reasonable runtime, as it only needs to iterate over the grid twice.
flow: |
  - Initialize a dp array with a large value at all positions except where there is a telephone pole (where we put 0).
  - Iterate over the grid in both directions (left to right and top to bottom, then right to left and bottom to top).
  - For each cell, take the minimum value between the current cell and the adjacent cell plus the distance between them.
  - The final dp array will contain the minimum distance from each cell to a telephone pole.
  - Square these distances and sum them up to get the final answer.
input_output_examples_flow: |
  - For the first example, the dp array after the first iteration would be [[0, 1, 0], [1, 2, 1], [2, 3, 2]]. After the second iteration, it would be [[0, 1, 0], [1, 2, 1], [2, 3, 2]]. Squaring these values and summing them up gives 18.
  - For the second example, the dp array after the first iteration would be [[0, 1, 2, 3, 0], [1, 2, 3, 4, 1], [0, 1, 2, 3, 2], [1, 2, 3, 0, 1], [2, 1, 0, 1, 2], [3, 2, 1, 2, 0]]. After the second iteration, it would be [[0, 1, 2, 3, 0], [1, 2, 1, 2, 1], [0, 1, 2, 1, 2], [1, 2, 1, 0, 1], [2, 1, 0, 1, 2], [3, 2, 1, 2, 0]]. Squaring these values and summing them up gives 36.
'

answer:
```python
2023-11-03 21:24:54.436 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def initialize_dp(grid, n, m):
    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        for j in range(m + 1):
            if grid[i][j] == 1:
                dp[i][j] = 0
    return dp

def calculate_distances(dp, n, m):
    for i in range(n + 1):
        for j in range(m + 1):
            if i > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)
    for i in range(n, -1, -1):
        for j in range(m, -1, -1):
            if i < n:
                dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1)
            if j < m:
                dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)
    return dp

def sum_squares(dp, n, m):
    total = 0
    for i in range(n + 1):
        for j in range(m + 1):
            total += dp[i][j] ** 2
    return total

def solve_problem():
    n, m = map(int, input().split())
    grid = [list(map(int, input())) for _ in range(n + 1)]
    dp = initialize_dp(grid, n, m)
    dp = calculate_distances(dp, n, m)
    total = sum_squares(dp, n, m)
    print(total)

if __name__ == "__main__":
    solve_problem()
2023-11-03 21:24:54.437 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:24:54.437 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:24:54.438 | INFO     | alpha_codium.gen.coding_competitor:run:85 - --iterate on public tests stage--
2023-11-03 21:24:54.438 | INFO     | alpha_codium.gen.coding_competitor:run:98 - test_inputs:
2 2
101
000
000

2023-11-03 21:24:58.563 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:24:58.564 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 -
2023-11-03 21:24:58.564 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 -
2023-11-03 21:24:58.564 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
2 2
101
000
000

2023-11-03 21:24:58.564 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
18
---
24
2023-11-03 21:24:58.564 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=None.
2023-11-03 21:24:58.564 | DEBUG    | alpha_codium.gen.coding_competitor:clip_string:160 - clipping string from 269 to 50
2023-11-03 21:24:58.565 | INFO     | alpha_codium.gen.coding_competitor:run:121 - counter: 1
2023-11-03 21:24:58.569 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:24:58.569 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:24:58.569 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:
You are an expert programmer and mathematician.

you are given a code contest problem, and a Python code solution.
However, when running the input example with the code, it failed to produce the expected output.

Your goal is to analyze the code and the error, find the bug in the code solution, and propose a fix to the code solution.
Offer a fix that will keep the solution robust and work for other input examples as well.


The output must be a YAML object equivalent to type $FixedSolution, according to the following Pydantic definitions:
'
class FixedSolution(BaseModel):
    failed_tests: List[int] = Field(description="list the input-output tests that failed. use the format [{input: .., expected_output: .., code_output: ..}, ...]")
    what_went_wrong: str = Field(description="Explanation shortly, in bullet points, what was the problem with the code solution, and how do you recommend to fix it. Be as specific as possible.")
    input_output_fixed_flow: str = Field(description="describe shortly, in bullet points, how the proposed fixed flow will lead to getting the expected output for the provided input example. Be as specific as possible. ")
'

Example YAML output:
```yaml
failed_tests: |-
  ...
what_went_wrong: |-
  ...
input_output_fixed_flow: |-
  ...
```
Each YAML output MUST be after a newline, indented, with block scalar indicator ('|-').


```
2023-11-03 21:24:58.569 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
problem name: '1575_M. Managing Telephone Poles'


problem description:
'
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.

There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.

For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.

To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
'

self reflection on the problem:
'
- The problem is about a city represented as a grid where there are some telephone poles. The grid is of size (n + 1) x (m + 1) and a telephone pole is present at a point (x, y) if a_{x, y} = 1.
- The task is to calculate the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
- The input consists of the size of the grid (n, m) and the grid itself, represented as a matrix of 0s and 1s, where 1 indicates the presence of a telephone pole.
- The output is an integer, the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
'

A solution code generated for the problem, that failed to get the expected output:
'
def initialize_dp(grid, n, m):
    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        for j in range(m + 1):
            if grid[i][j] == 1:
                dp[i][j] = 0
    return dp

def calculate_distances(dp, n, m):
    for i in range(n + 1):
        for j in range(m + 1):
            if i > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)
    for i in range(n, -1, -1):
        for j in range(m, -1, -1):
            if i < n:
                dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1)
            if j < m:
                dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)
    return dp

def sum_squares(dp, n, m):
    total = 0
    for i in range(n + 1):
        for j in range(m + 1):
            total += dp[i][j] ** 2
    return total

def solve_problem():
    n, m = map(int, input().split())
    grid = [list(map(int, input())) for _ in range(n + 1)]
    dp = initialize_dp(grid, n, m)
    dp = calculate_distances(dp, n, m)
    total = sum_squares(dp, n, m)
    print(total)

if __name__ == "__main__":
    solve_problem()
'


Error message when running the 'solution code':
'
test input:
2 2
101
000
000

expected output:
18
code output:
24
====================
====================
'

Output YAML:
```yaml
2023-11-03 21:25:09.985 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
failed_tests: |-
  - {input: '2 2\n101\n000\n000\n', expected_output: '18\n', code_output: '24\n'}

what_went_wrong: |-
  - The code is not correctly calculating the Euclidean distance. It's using Manhattan distance instead.
  - The distance calculation in the function 'calculate_distances' is incorrect. It's adding 1 to the previous cell's distance, which is not the correct way to calculate Euclidean distance.
  - The correct way to calculate Euclidean distance between two points (x1, y1) and (x2, y2) is sqrt((x2 - x1)^2 + (y2 - y1)^2), but the code is not doing this.

input_output_fixed_flow: |-
  - Initialize the dp array with infinity for all cells except those with a telephone pole, where the value should be 0.
  - For each cell in the grid, calculate the Euclidean distance to each telephone pole and keep the minimum distance.
  - Square the minimum distance and add it to the total sum.
  - Continue this process for all cells in the grid.
  - The total sum will be the required output.
2023-11-03 21:25:09.985 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:25:09.986 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:25:09.993 | INFO     | alpha_codium.llm.ai_handler:chat_completion:110 - -----------------
2023-11-03 21:25:09.993 | INFO     | alpha_codium.llm.ai_handler:chat_completion:111 - Running inference ...
2023-11-03 21:25:09.993 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:112 - system:
You are an expert programmer and mathematician.

you are given a code contest problem, and a Python code solution.
However, when running the input-output example test, the code failed to produce the expected output.
Using the provided analysis, you need generate a fixed solution code, that will pass all the tests.

guidelines:
- The fixed solution code must pass all the tests, and have a reasonable runtime and memory complexity.
- Always double-check the new solution code, and test it on multiple edge cases, and the provided input-output examples.
- Make sure the new solution code generalizes to all possible input-output examples, and not only to the provided input-output examples.
- You must divide the new solution code into small sub-functions, with meaningful names and functionality

The code output must follow this structure:
````
def f1(...):
    ...
    return ...

def f2(...):
    ...
    return ...
...

if __name__ == "__main__":
    ...
```
The code should read the input using the 'input()' method. Make sure to properly parse the input, according to the problem description.
The output should be printed without additional words using the 'print()' method.

2023-11-03 21:25:09.993 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:113 - user:
problem name: '1575_M. Managing Telephone Poles'


problem description:
'
Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.

There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) × (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.

For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.

To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 ≤ x ≤ n and 0 ≤ y ≤ m. Help him by finding the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Input

The first line contains two integers n and m (0 ≤ n, m < 2000) — the size of the grid.

Then (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 ≤ a_{i, j} ≤ 1) — the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.

Output

Output an integer denoting the value of ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}}.

Examples

Input


2 2
101
000
000


Output


18


Input


5 4
10010
00000
01000
00001
00100
00010


Output


36

Note

<image>

In the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, ∑_{x=0}^{n} {∑_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.
'

self reflection on the problem:
'
- The problem is about a city represented as a grid where there are some telephone poles. The grid is of size (n + 1) x (m + 1) and a telephone pole is present at a point (x, y) if a_{x, y} = 1.
- The task is to calculate the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
- The input consists of the size of the grid (n, m) and the grid itself, represented as a matrix of 0s and 1s, where 1 indicates the presence of a telephone pole.
- The output is an integer, the sum of the squares of the Euclidean distances from each point in the grid to the nearest telephone pole.
'

A solution code generated for the problem, that failed to get the expected output:
'
def initialize_dp(grid, n, m):
    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        for j in range(m + 1):
            if grid[i][j] == 1:
                dp[i][j] = 0
    return dp

def calculate_distances(dp, n, m):
    for i in range(n + 1):
        for j in range(m + 1):
            if i > 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)
            if j > 0:
                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)
    for i in range(n, -1, -1):
        for j in range(m, -1, -1):
            if i < n:
                dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1)
            if j < m:
                dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)
    return dp

def sum_squares(dp, n, m):
    total = 0
    for i in range(n + 1):
        for j in range(m + 1):
            total += dp[i][j] ** 2
    return total

def solve_problem():
    n, m = map(int, input().split())
    grid = [list(map(int, input())) for _ in range(n + 1)]
    dp = initialize_dp(grid, n, m)
    dp = calculate_distances(dp, n, m)
    total = sum_squares(dp, n, m)
    print(total)

if __name__ == "__main__":
    solve_problem()
'

Error message when running the 'solution code':
'
test input:
2 2
101
000
000

expected output:
18
code output:
24
====================
====================
'

what_went_wrong;
'
- The code is not correctly calculating the Euclidean distance. It's using Manhattan distance instead.
- The distance calculation in the function 'calculate_distances' is incorrect. It's adding 1 to the previous cell's distance, which is not the correct way to calculate Euclidean distance.
- The correct way to calculate Euclidean distance between two points (x1, y1) and (x2, y2) is sqrt((x2 - x1)^2 + (y2 - y1)^2), but the code is not doing this.
'

input_output_fixed_flow:
'
- Initialize the dp array with infinity for all cells except those with a telephone pole, where the value should be 0.
- For each cell in the grid, calculate the Euclidean distance to each telephone pole and keep the minimum distance.
- Square the minimum distance and add it to the total sum.
- Continue this process for all cells in the grid.
- The total sum will be the required output.
'

answer:
```python
2023-11-03 21:25:21.959 | DEBUG    | alpha_codium.llm.ai_handler:chat_completion:137 - response:
def initialize_dp(grid, n, m):
    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
    poles = []
    for i in range(n + 1):
        for j in range(m + 1):
            if grid[i][j] == 1:
                dp[i][j] = 0
                poles.append((i, j))
    return dp, poles

def calculate_distances(dp, poles, n, m):
    for i in range(n + 1):
        for j in range(m + 1):
            for pole in poles:
                dp[i][j] = min(dp[i][j], (i - pole[0]) ** 2 + (j - pole[1]) ** 2)
    return dp

def sum_squares(dp, n, m):
    total = 0
    for i in range(n + 1):
        for j in range(m + 1):
            total += dp[i][j]
    return total

def solve_problem():
    n, m = map(int, input().split())
    grid = [list(map(int, input())) for _ in range(n + 1)]
    dp, poles = initialize_dp(grid, n, m)
    dp = calculate_distances(dp, poles, n, m)
    total = sum_squares(dp, n, m)
    print(total)

if __name__ == "__main__":
    solve_problem()
2023-11-03 21:25:21.959 | INFO     | alpha_codium.llm.ai_handler:chat_completion:138 - done
2023-11-03 21:25:21.959 | INFO     | alpha_codium.llm.ai_handler:chat_completion:139 - -----------------
2023-11-03 21:25:21.960 | INFO     | alpha_codium.gen.stages.run_fix_code_from_tests_failure:run_fix_code_from_tests_failure:30 - diff:
---
+++
@@ -1,38 +1,32 @@
 def initialize_dp(grid, n, m):
     dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
+    poles = []
     for i in range(n + 1):
         for j in range(m + 1):
             if grid[i][j] == 1:
                 dp[i][j] = 0
-    return dp
+                poles.append((i, j))
+    return dp, poles

-def calculate_distances(dp, n, m):
+def calculate_distances(dp, poles, n, m):
     for i in range(n + 1):
         for j in range(m + 1):
-            if i > 0:
-                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)
-            if j > 0:
-                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)
-    for i in range(n, -1, -1):
-        for j in range(m, -1, -1):
-            if i < n:
-                dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1)
-            if j < m:
-                dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)
+            for pole in poles:
+                dp[i][j] = min(dp[i][j], (i - pole[0]) ** 2 + (j - pole[1]) ** 2)
     return dp

 def sum_squares(dp, n, m):
     total = 0
     for i in range(n + 1):
         for j in range(m + 1):
-            total += dp[i][j] ** 2
+            total += dp[i][j]
     return total

 def solve_problem():
     n, m = map(int, input().split())
     grid = [list(map(int, input())) for _ in range(n + 1)]
-    dp = initialize_dp(grid, n, m)
-    dp = calculate_distances(dp, n, m)
+    dp, poles = initialize_dp(grid, n, m)
+    dp = calculate_distances(dp, poles, n, m)
     total = sum_squares(dp, n, m)
     print(total)


2023-11-03 21:25:26.132 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:25:26.132 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 -
2023-11-03 21:25:26.132 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 -
2023-11-03 21:25:26.132 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
2 2
101
000
000

2023-11-03 21:25:26.132 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
18
---
18
2023-11-03 21:25:26.132 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:25:26.133 | DEBUG    | alpha_codium.gen.coding_competitor:clip_string:160 - clipping string from 255 to 50
2023-11-03 21:25:26.133 | INFO     | alpha_codium.gen.coding_competitor:run:121 - counter: 2
2023-11-03 21:25:26.133 | INFO     | alpha_codium.gen.coding_competitor:run:123 - Passed public tests after 2 attempts
2023-11-03 21:25:26.133 | INFO     | alpha_codium.gen.coding_competitor:run:98 - test_inputs:
5 4
10010
00000
01000
00001
00100
00010

2023-11-03 21:25:30.230 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:25:30.230 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 -
2023-11-03 21:25:30.231 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 -
2023-11-03 21:25:30.231 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
5 4
10010
00000
01000
00001
00100
00010

2023-11-03 21:25:30.231 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
36
---
36
2023-11-03 21:25:30.231 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:25:30.231 | DEBUG    | alpha_codium.gen.coding_competitor:clip_string:160 - clipping string from 1044 to 50
2023-11-03 21:25:30.231 | INFO     | alpha_codium.gen.coding_competitor:run:121 - counter: 1
2023-11-03 21:25:30.231 | INFO     | alpha_codium.gen.coding_competitor:run:123 - Passed public tests after 1 attempts
2023-11-03 21:25:30.231 | INFO     | alpha_codium.gen.coding_competitor:run:151 - Passed public tests
2023-11-03 21:25:30.233 | INFO     | alpha_codium.gen.coding_competitor:solve_problem:181 - testing solution on private tests with prediction:
def initialize_dp(grid, n, m):
    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
    poles = []
    for i in range(n + 1):
        for j in range(m + 1):
            if grid[i][j] == 1:
                dp[i][j] = 0
                poles.append((i, j))
    return dp, poles

def calculate_distances(dp, poles, n, m):
    for i in range(n + 1):
        for j in range(m + 1):
            for pole in poles:
                dp[i][j] = min(dp[i][j], (i - pole[0]) ** 2 + (j - pole[1]) ** 2)
    return dp

def sum_squares(dp, n, m):
    total = 0
    for i in range(n + 1):
        for j in range(m + 1):
            total += dp[i][j]
    return total

def solve_problem():
    n, m = map(int, input().split())
    grid = [list(map(int, input())) for _ in range(n + 1)]
    dp, poles = initialize_dp(grid, n, m)
    dp = calculate_distances(dp, poles, n, m)
    total = sum_squares(dp, n, m)
    print(total)

if __name__ == "__main__":
    solve_problem()
2023-11-03 21:25:34.499 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:51 - compilation results:ProgramStatus.kSuccess
2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:53 -
2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:54 -
2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
9 9
0000110000
0001001000
0001001000
0001111000
0001001000
0001001000
0110000110
1000000001
1001001001
0111111110

2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
182
---
182
2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-0 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:57 - input:
0 0
1

2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:58 - expected vs code output:
0
---
0
2023-11-03 21:25:34.500 | INFO     | alpha_codium.code_contests.eval.code_test_runners:print_test_results:72 - test-1 :: status=ProgramStatus.kSuccess, passed=True
2023-11-03 21:25:34.501 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:213 - =====================================
2023-11-03 21:25:34.501 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:214 - test_passed: 2, test_failed: 0
2023-11-03 21:25:34.501 | INFO     | alpha_codium.gen.coding_competitor:solve_and_test:215 - =====================================
